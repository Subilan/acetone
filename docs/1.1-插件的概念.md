# 1.1 插件的概念

## 接口

你是否思考过什么叫做**插件（plugin）**？

从英文角度来理解，`plugin` 实际上是一个合成词，它原本指的是一个动作，即 `plug in`。它逐渐演变成了这样一种名词的形式，因而 `plugin` 也能写作 `plug-in`。Plug in 这个动作，可以理解为把插头插进插座里。将这个动作抽象化、名词化以后，就出现了「插入的东西」的概念，我们称这个「插入的东西」为「插件」。

插件作为半路插入的东西，游戏本身并没有它。它通过自己的代码对游戏起到了一定的拓展与改变作用。究竟是什么能让一个不是游戏原作者写的程序控制这款游戏？那就是**应用程序接口（application programming interface, *abbr.* API）**，在本文中简称**接口（interface）**。接口有很多种，而且相互之间的概念也并不重合。在本文中，我们的接口都是指「将 Minecraft 本体与插件衔接起来的中间体」。

接口是凭空产生的吗？并不是，接口是需要人为编写的。接口本质上是一种约定，约定你应该以怎样的方式与程序沟通。在学会 Java 语言的基础上了解接口，就可以顺利地写插件。接口就好比语言中的方言，你到达了一个小地方，想要和那里的人沟通，就必须了解当地的方言——而如果你只会普通话，就有可能根本无法和他们沟通。

Minecraft 的接口很特殊，它并不是由官方所创造的。也许你早已听说过官服与「水桶服」的区别——一个不能加插件，一个可以加插件，道理也就在这里。

## 服务端

接口是由 **服务端（server）** 所提供的（更严格地说，是由服务端和插件共同实现的），如果你按照接口的规定写，并且按照规则放在了 `plugins` 文件夹下面，那么就可以与服务端本身建立沟通，服务端就可以将你的插件应用到玩家所看到的世界里。那么，服务端究竟是一个怎样的存在？

一个完整的服务器游戏体验，分为 **客户端（client）** 和 **服务端（server）** 两个部分，在许多计算机软件中也是这样。客户端就是 Minecraft 游戏本体，你可以在这个游戏中选择「多人游戏」去连接到一个服务器里。所谓「服务器」本质就是服务端。服务端实际上是一个请求处理者，它提供的只是对你行为的种种反应，游戏体验则还是由客户端决定。进入服务器游玩的本质是 **发送请求（send request）** 和 **接收回应（receive response）**，这里的请求指的就是某种形式的数据。

例如，进入服务器首先需要加载地形，地形的数据就是由服务端发来的（因为地图存档并不在你的电脑上，这是一个服务器的基本特征）。客户端依据发来的数据开始加载本地的地形以让玩家看到，这样一个世界就形成了。玩家的每一次移动、每一句聊天指令等，均会发往服务端，服务端也会将结果发送回来。细心的读者可以想到，在这里服务端和客户端之间一定也存在着某种「约定」，因为只有这样客户端才能读懂服务端发回的数据以及发送服务端可以读懂的数据。

于是这里我们引用 tdiant 大佬在 [Bukkit Development Note](https://bdn.tdiant.net/#/unit/2-2?id=%e7%90%86%e8%a7%a3%e5%ae%a2%e6%88%b7%e7%ab%af%e4%b8%8e%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%9a%84%e5%85%b3%e7%b3%bb) 中提到的一个例子。为什么领地插件在禁止你走动的时候，你往往是动了以后又回到原位，而不是根本不能动呢？这是因为「走动」是一种客户端行为（任何游戏本体的操作都是客户端行为），在服务器这个特殊环境里，客户端需要将玩家的一举一动都发往服务端，而在客户端发往服务端，并未收到请求的时候，这些行为并不会被处理（按照本地游戏的方式表现出来，走了就是走了），而当服务端通过插件的代码得出结论，返回一个「禁止走动」的回应时，客户端就会取消「走动」这个动作，玩家也就会回到原本的地方，**相当于没有走动**。

以上，就是服务端的粗略概念。不同的服务端提供了不同的插件运行载体，也向插件提供了不同的接口。下面，我们就来简单地认识不同的服务端及其对应的接口。

### 官服

官方只推出过一种服务端，那就是官方服务器，简称官服，习惯称之为 **Vanilla**。官服不提供对外的接口，意思是你没有办法把插件放到官服里去运行。在运行的时候你会发现，目录下并没有生成名为 `plugins` 的文件夹。

### Bukkit，Spigot 和 Paper

这三者是**插件服务器**中的主流服务端，但 Bukkit 考虑性能问题已经很少有人使用。这三者实际上是 acetone 所要讲述的重点，他们彼此之间存在着密切的联系。那么到底是什么联系呢？

实际上，Spigot 是 Bukkit 的 **fork（派生）**，Paper（也叫 Paper Spigot）是 Spigot 的 fork。

> **Fork** 可以通俗地理解为「在原有的基础上再开发」。也就是说，Spigot 是在 Bukkit 的代码上又进行额外的开发得出的一个分支版本，Paper 和 Spigot 也是这种关系。

它们这种关系的特点就是，后者可以继承前者几乎所有属性。也就是说，Spigot 上可以运行所有 Bukkit 的插件，Paper 上可以运行所有 Spigot 的插件。

照这样继承下来，不都可以运行 Bukkit 的插件了吗？是的，但是它们也有它们自己的插件支持范畴。即存在一种插件只能在 Spigot 上运行而无法在 Bukkit 上运行的，也存在一种插件只能在 Paper 上运行而无法在 Spigot 上运行的，但不存在插件只能在 Bukkit 上运行。我们通常接触的插件一般没有这些特点，这些特点也是由接口的实现来决定的。

这三者有各自的接口，即 Bukkit API、Spigot API 和 Paper API，它们之间的关系实际上就是这三者之间的派生关系。这三者实际上大部分都是一样的，在后文中我们将省略不一样的部分不提。

### Sponge

Sponge 是一个统称，实际上分为 SpongeVanilla 和 SpongeForge。SpongeVanilla 也是插件服务器的服务端，但拥有一个独特的 API——Sponge API，它完完全全从 Bukkit 生态圈中脱离出来了。

SpongeForge 是 Mod 服务器的服务端，也算是主流。本文不会提及任何有关 Mod 开发的知识，~~因为我不会。~~ 它实现了 Sponge API 来提供对相关插件的支持，同时它也实现了 Forge API 来支持 Mod。

### Mohist、Catserver、Arclight 等

这类服务端一样是 Mod 服务器的服务端，但也支持 Bukkit 插件（我们通常习惯把实现了 Bukkit API 等接口的插件称作 Bukkit 插件）的安装。它们既实现了对 Forge API 的支持，也实现了对 Bukkit API 的支持。

Forge API 和 Fabric API 是 **客户端（client）** 流行的两种 Mod 接口，服务端需要实现它们才能把 Mod 带到服务端。

以下是一个关于服务端与 API 的关系的简表。

|服务端|API|支持的插件与 Mod 类型|
|:-:|:-:|:-:|
|Vanilla|无|无|
|Bukkit|Bukkit API|实现了 Bukkit API 的插件|
|Spigot|Spigot API|实现了 Bukkit 或 Spigot API 的插件|
|Paper|Paper API|实现了 Bukkit 或 Spigot 或 Paper API 的插件|
|SpongeForge|Sponge API, Forge API|实现了 Sponge API 的插件和实现了 Forge API 的 Mod|
|SpongeVanilla|Sponge API|实现了 Sponge API 的插件|
|Mohist 等|Bukkit 等 API, Forge API|实现了 Bukkit 等 API 的插件和实现了 Forge API 的 Mod|

Acetone 主要讲述 Bukkit 等 API 的开发方式，而这些方式和思想是可以通用的。

## 插件

通过上文的阅读，我们应该可以给插件下一个定义了。**Minecraft 服务端插件**是一种以特定服务端对应的 API 为实现标准，通过代码上对 API 的实现来对服务端处理客户端请求的过程发挥作用的 Java 应用程序。通俗来讲，就是通过影响服务端来影响客户端，从而塑造游戏体验或者创造功能的程序。Acetone 主要介绍对 Bukkit 等 API 的实现，以下我们就来进行插件开发的第一步。

### 环境部署

环境部署可以说简单也可以说复杂，实际上取决于自己的需求。本文中介绍的是通过简易版 Gradle 和 Visual Studio Code 来部署针对于 Minecraft 服务端插件的开发环境，实际上也有例如 IntelliJ IDEA 的 IDE 解决方案。

#### 1. Java 环境

> Ubuntu 若要安装 Java（推荐 OpenJDK）可以在终端键入 `sudo apt-get install openjdk-版本-jdk-headless`

Java 是 Minecraft 的基础，也是插件的基础。要安装 Java，请先到[这里](https://www.oracle.com/java/technologies/javase-downloads.html)下载 Java 的安装程序。请确保下载到的是 JDK（Java Development Kit，Java 开发包）而不是 JRE（Java Runtime Environment，Java 运行时环境），后者只能运行 Java 程序而不能用来编写。

在开发过程中，我们要了解的关于 Java 本体的只有一个参数，就是它的发行版本。作为普通开发者，我们只使用 Java SE（Standard Edition 标准版，除此之外还有 Micro Edition 和 Enterprise Edition，这些统称为平台版本），而发行版本则不一定了。通常我们接触到的发行版本有三个，Java 8、Java 11 和 Java 16。通过下表你可以了解到这三个版本之间的区别以及在开发过程中的特点。

|版本|特点|
|:-:|:-:|
|8|[从 1.12.2 开始](https://help.minecraft.net/hc/en-us/articles/360035131371-Minecraft-Java-Edition-System-Requirements-)，Minecraft 要求的最低 Java 版本为 Java 8。目前许多插件的编写仍然可以使用 Java 8 来完成。
|11|Java 11 是一个 LTS（Long Term Support，长期支持）版本，之前一个是 Java 8。Java 11 提供了很多 8 没有的特性，同样可以用来运行 Minecraft 客户端和服务端。
|16|**从 1.17 开始，Minecraft 要求的最低 Java 版本为 Java 16，插件从此也必须至少使用 Java 16 来编写。**|

在 Minecraft 本体支持的前提下，不同的 Java 版本之间最主要的区别就是其提供的 Java 本体 API 不一样。例如 Java 11 加入了 `String.isBlank()`，用来判断一个字符串是否为空，这在之前的 Java 版本中均无法使用。如果你用不到这些 API，则可以随性选择。

下载完安装程序后安装即可。安装完毕后，在命令行中键入 `java --version`（Java 8 请使用 `java -v`）。如果出现版本号，代表安装成功。

![](https://i.loli.net/2021/07/31/IK29V31M6btunrd.png)

如果找不到 `java` 这个指令，则有可能是环境变量出现问题。在命令行或者 <kbd>Win</kbd>+<kbd>R</kbd> 弹出的运行窗口键入 `rundll32 sysdm.cpl,EditEnvironmentVariables` 即可快速打开环境变量控制面板，编辑环境变量 `Path`，添加一个项目指向 `java.exe` 所在位置即可。

<p align="center">
    <img src="https://i.loli.net/2021/07/31/UQk6H8BRdbTh94q.png"/>
</p>

<p align="center">
    <img src="https://i.loli.net/2021/07/31/wXsHTkUWBKpg74l.png">
</p>

#### 2. 开发环境

Java 安装好了以后只是奠定了基础，我们还需要搭建我们日常写代码的地方。一个插件需要写代码、测试然后编译后发布，因而这个地方应当满足我们这些需求。

首先，要找到一个写的地方，在本文我们使用 Visual Studio Code。如果对 IntelliJ IDEA 感兴趣，可以转到[这篇教程](https://github.com/guobinhit/intellij-idea-tutorial)（我通过搜索找到的，并不是推荐）。

下载和安装 Visual Studio Code 就不多解释，官网链接为 <https://code.visualstudio.com>。安装以后打开，在拓展程序里面安装 Java 相关插件（看！「插件」成了一个熟悉的概念）。本文推荐使用的插件是 [Red Hat 的 Language Support for Java(TM)](https://marketplace.visualstudio.com/items?itemName=redhat.java)，直接在拓展程序里搜索 `java` 即可。

<p align="center">
    <img src="https://i.loli.net/2021/07/31/ZUyhvlk4gf8EiVq.png">
</p>

安装好以后，基本上不需要设置，开发环境就已经搭建完毕（只要之前的 Java 安装没有出现问题，路径是正常的路径即可）。

> 请注意：Visual Studio Code 能提供的功能远远少于 IntelliJ IDEA 等专业 IDE，但是对于学习代码来说却显得十分轻量。不同的人可以根据自己的需求来选择不同的 IDE，如果只是写插件用作学习、小作品而不牵涉大项目时，VSC 也是可以接受的。IntelliJ IDEA 的学习成本稍高，但并不属于劝退类型，且大多数特性基本上用不到。

#### 3. 项目

接下来我们要创建我们的代码存放地。这基本上就是一个模板，以后所有的项目基本上均按照我们下面所介绍的结构来存放（当然也有其它的方法，本文只是示例），不同的只是代码。新建一个文件夹，叫做 `my-plugin`。在这个文件夹里，拥有如下结构

```
my-plugin
│  build.gradle
│  settings.gradle
│  gradlew
│  gradlew.bat
│  settings.gradle
├─.gradle
├─gradle
│  └─wrapper
└─src
    └─main
        ├─java
        └─resources
```

下表解释了每个文件夹、文件的意义和作用。

|文件或文件夹|作用|
|:-:|:-:|
|`build.gradle`|用于指定该项目的构建信息，例如该项目的版本、兼容性等。最重要的是，该文件可以用来添加**依赖（dependency）**。API 本身也是依赖，因此该文件不可或缺。|
|`settings.gradle`|用于配置项目本身。|
|`gradlew` 和 `gradlew.bat`|是用来调用 gradle 本体的两个脚本。没有加 `.bat` 的用于 bash，加了 `.bat` 的用于 Windows 的 cmd。|
|`.gradle`|用于存放 gradle 的临时文件，如不同版本的 gradle 等。|
|`gradle`|用于存放 gradle 的包装器 gradle-wrapper。|
|`src`|是代码的存放地，整个项目的代码全部在该文件夹内。|
|`src/main`|主程序代码的存放地，开发插件时必须放在 `main` 内。|
|`src/main/java`|程序代码的存放地，用于存放代码，其目录结构反映了包的结构。|
|`src/main/resources`|插件本体的相关文件的存放地。该文件夹内必须包含一个 `plugin.yml` 用于声明该插件本身的一些信息，如版本、指令、权限等。|

如果对 Java 不甚了解，也许从这个环节就会感到疑惑。但是在这里还是尽可能将上文可能存在的疑点进行解释。

- **Gradle 是什么？它有必要吗？** Gradle 是一个包管理程序，你可以通俗地认为它是用来管理你项目本身的编译和发布事项，同时提供一个将其它需要的项目引入的途径的第三方程序。Gradle 与 Maven 并列，你也可以选择 Maven 作为包管理程序，它们的原理大同小异。本文仅介绍 Gradle。
- **Gradle Wrapper 又是什么？Gradle 不需要下载安装吗？** 由于 Gradle 本身是多变的，包括其版本和调用方式，所以出现了 Wrapper（包装器）的概念，也就是对 Gradle 进行包装，包装以后的结果就是一个统一调用方式的程序，以便于使用。Gradle Wrapper 在我们的项目中起到的作用就是调用 Gradle 本体进行一系列的操作（如构建）。Gradle 可以[下载](https://gradle.org)，也可以直接通过文件来调用 Gradle Wrapper，笔者推荐后者。
- **依赖是什么？** 插件作为一个 Java 应用程序，包含其本身的一些特点。我们一般把我们自己写的代码称为 **本地代码（local）**，这些代码是我们自己创造的。而在编写过程中如果需要引用别人的库或者代码，则需要将别人的东西先搞来（下载到本地），然后导入，这是很麻烦且不优雅的，且在更新迭代的时候会出现一些问题。因而包管理程序们提供了一个优雅的解决方式，构建了一个网上的平台（[MVN Repository](https://mvnrepository.com/)）让开发者们把自己的「作品」发在上面，如果有人有需要则可以直接通过一个链接将其作为**依赖**导入自己的项目里。这一系列操作在内部均由包管理程序实现。Bukkit API 等 API 均是外部的东西，因而我们必须要把它作为依赖「导入」，才能正常编写。当然不是所有的依赖都在 MVN Repository 上面，平台有很多。有的开发者拥有自己的平台。
- **包的结构是指什么？** 这是 Java 的必修课。通俗来讲，如果你想要写一个 Java 程序，它必须有自己的包名，这是约定。包名一般由域名+本地包名组成，例如如果我自己的网站是 `subilan.win`，我写了程序叫做 PerfectApplication，那么它的包名就是 `win.subilan.PerfectApplication`，对应的目录结构就是 `win/subilan/PerfectApplication/`，放在本项目中，我的代码就应该全部放在 `src/main/java/win/subilan/PerfectApplication` 下面。当然，包名是自由的，这和你有没有自己的网站没有必然联系。域名的根本目的是将你自己的作品与他人的作品「隔开」。很有可能有另外一个人也写了一个 PerfectApplication，那么既然彼此拥有不一样的域名，就不会产生冲突。
- **我该从哪里搞到这些文件？** 如果你对 gradle 不甚了解，我建议你直接从[这里](#)下载，然后复制到你的项目里面。请注意：该链接下载的是我一直使用的版本，它们并不支持 Java 16 的开发。如果你对 gradle 了解或者有意向学习，请前往[官网](https://gradle.org/)查看相关内容，有关 Gradle Wrapper 的文档在[这里](https://docs.gradle.org/current/userguide/gradle_wrapper.html)。

接下来介绍 `plugin.yml`、`build.gradle` 和 `settings.gradle` 里面该写些什么。这些文件共同决定了整个项目独一无二的性质。先说最简单的 `settings.gradle`。

```groovy
rootProject.name = '项目名称'
```

只有这一行内容。填写你的项目名称即可。如需了解更多可以放在这个文件里面的项目，可以查看[这里](https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:settings_file)。

然后是 `build.gradle`，请先参考以下结构和注解。

```groovy
plugins {
    id 'java'
}

group 'com.example' // 包前面的域名部分
version '1.0.0' // 项目的版本
ext.minecraftVersion = '1.16.5' // 这是一个变量，填当前插件所使用的 API 对应的版本。
mainClassName = 'com.example.MyPlugin.Main' // 主类地址。前面的 com.example.MyPlugin 是包名，Main 是类名

jar {
    manifest {
        attributes "Main-Class": "$mainClassName" // 这里引用了上面的变量，用来指定主类。
    }

    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it)}
    }
}

sourceCompatibility = 11 // 代码的兼容版本（Java）

repositories { // 这里写的都是仓库的地址，仓库就是上文中所说的「平台」。这里相当于是在引入这些仓库
    jcenter()
    mavenCentral()
    maven { name 'Spigot'; url 'https://hub.spigotmc.org/nexus/content/repositories/snapshots/' } // 这个就是 Spigot 自己的仓库，引入以后才能获取到 Spigot API
    maven { name 'Sonatype'; url 'https://oss.sonatype.org/content/groups/public' }
}

dependencies {
    compileOnly "org.spigotmc:spigot-api:$minecraftVersion-R0.1-SNAPSHOT" // 导入 Spigot API 相应版本作为依赖。注意此处用到了上面的版本变量
    testImplementation 'junit:junit:4.13'
    testImplementation 'com.google.code.findbugs:jsr305:3.0.2'
}

tasks.withType(JavaCompile) { // 指定编译时的编码
    options.encoding = "UTF-8"
}
```

实际上 `build.gradle` 和 `settings.gradle` 都是用一种叫做 Groovy 的语言写的，相当于比较随意的 Java 吧，了解一下即可。`build.gradle` 内需要着重掌握的地方，其实只有 `dependencies` 环节和开头的 `group`、`version` 等量。如果在编写插件时需要引入依赖，通常的流程是找到依赖的发布地址 -> 加入到 `dependencies` 里面。以 [NekoCommander](https://github.com/neko-craft/NekoCommander) 为例，作者在 `README.md` 里面写了如下内容

![](https://i.loli.net/2021/07/31/7qxCQ3T4gtSzXmM.png)

意思就是让你到 `build.gradle` 的相应部分添加相关内容。添加完毕以后，等待片刻（或者重启 VSC 的窗口，<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>，输入 Reload Window 后 <kbd>enter</kbd>），项目中即可直接 `import` 相关包。

关于 `plugin.yml`，请参考以下结构和注解

```yml
name: MyPlugin # 插件的名称
main: com.example.MyPlugin.Main # 插件的主类地址
version: "1.0.0" # 插件的版本
author: Myself # 插件的作者，如果有多个可以写成 [A, B, C, ...]
api-version: "1.16" # 插件所使用的 API 版本
api: []
depend: []
softdepend: []
website: "https://example.com"

commands: # 插件的指令
  myplugin: # 指令名称
    aliases: ["my"] # 指令别名，此时 /my 和 /myplugin 等价
    description: Myplugin command # 指令介绍
    permission: myplugin.command # 指令对应的权限
    permission-message: "You do not have the permission to use the command." # 没有权限时要显示的信息
    usage: The command is invalid or you don't have the permission to use it. # 指令的用法信息
permissions: # 插件的权限
  myplugin.use: # 权限名称
    default: true # 默认给予所有玩家
  myplugin.admin:
    default: op # 默认给予 OP 玩家
  myplugin.never:
    default: false # 默认不给予玩家
```

该文件内的信息决定了插件在服务端内的最终表现。如果没有正常填写，无论其它文件是否正常填写，服务端均无法处理。例如如果主类填写错误，那么服务端将无法 enable 该插件。服务端内显示的该插件的版本号也是由该文件所控制。有关 `plugin.yml` 完整的解释，可以查看 [Spigot 官方 Wiki](https://www.spigotmc.org/wiki/plugin-yml)。

以上就是环境部署部分。

### 插件编写

TBC 2021/08/01
