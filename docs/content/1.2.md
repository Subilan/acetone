# 我们的第一个插件

在 1.1 中我们了解了我们在编写插件时所要知道的一些基本概念和思想，现在，让我们正式展开插件的编写。这部分内容与 Java 本身紧密联系，对于一些特殊的概念将会加粗，然后在文中以插入块的形式具体讲解。

为了后文的叙述清楚，我们在这里约定：
- 我们的插件名称叫做 `MyPlugin`
- 我们的插件包名为 `com.example.myPlugin`，因此我们的**主类**所在位置应当是 `/src/main/java/com/example/myPlugin`
- 我们的所有操作发生在 `/src/main/java/com/example/myPlugin` 内，并将此地址简记为 `@`
    - 例如，`@/MyPlugin.java` 则代表 `/src/main/java/com/example/myPlugin/MyPlugin.java`
- 我们的插件使用 Java 11 开发

除非声明，否则均按照此处所列信息看待。

## 主类

**主类**是插件的起点。你也许听说过 C++ 里的 `int main()` 吧？那也是一个主类。主类可以认定为是整个程序的入口。那么既然它是主类，就必定有和其它「普通的类」有区别的地方——插件的主类继承了 `JavaPlugin` 这个接口（此处的接口为 Java 内部概念，与前文叙述的不一致）。

接下来我们创建 `@/Main.java`，并将它看作主类，一个主类通常具有以下基本结构。

```java
// @/Main.java
package com.example.myPlugin; // 这里指定了当前文件所在的包，根据文件所在的位置会有所变化。

import org.bukkit.Bukkit; // 引入
import org.bukkit.plugin.java.JavaPlugin;

public final class Main extends JavaPlugin {
    @Override
    public void onEnable() {
        saveDefaultConfig();
        this.getLogger().info("MyPlugin is enabled.");
    }

    @Override
    public void onDisable() {
        this.getLogger().info("MyPlugin is disabled.");
    }
}
```

:::tip
**Java 语言讲堂 #1**

从这里开始，每相隔一两小节将会出现这样一个帮助你理解 Java 语言本身的小块，你可以选择性地阅读。内容不保证权威性，如需学习，请自行寻找专业教材，同时欢迎纠正。

- `package <包名>` 表达了当前文件所在的包，其与路径有关系。由于我们的 `Main.java` 放置在 `@` 下面，也就是 `/src/main/java/com/example/myPlugin` 这个目录下，所以包名写作 `com.example.myPlugin`。
    - 想一想：如果我将 `Main.java` 放置在 `@/Utils` 这个文件夹下面，包名应该写作什么？类比即可得出答案：`com.example.myPlugin.Utils`。请注意：包名并不能随意地写。
- `import <包名>` 导入了相应包下的类、接口等元素。例如，`org.bukkit` 是 `Bukkit` 这个类的包名，如果我们要导入 `Bukkit`，我们就可以用 `org.bukkit.Bukkit` 来代表它，然后 `import` 它即可使用。
- `public final class <类名>` 中 `public` 代表是「可以被外界访问的」，除此之外还有 `protected` 和 `private` 两种。主类只能为 `public` 类。`final` 表示「最终的」，即当前类不能被**继承**。实际上，如果没有相关需求，`final` 是否加上是没有影响的。
- `extends <类/接口/...>` 继承指定的对象。这是面向对象编程的特色，具体的含义不在这里详细讲解。但你可以尝试从字面意义上理解，「继承」即代表享有被继承对象所具有的项目。上面的 `final` 关键字可以防止某个对象被继承。
- `@Override` 是一个 Java Annotation（注解），除此之外还有 `@Deprecated` 等。它们相当于是可以影响编译行为的「小工具」。Override 单词本意是「覆盖」，在这里的意思是「覆盖父类的相关方法」。因为 `Main` 这个类继承了 `JavaPlugin`，所以在它内部的方法上面加上 `@Override` 就是在表明 `JavaPlugin` 这个父类里面也有同名的方法，并要用子类的方法去覆盖它。这样做可以保证接口被准确实现。如果父类中不存在子类中被 `@Override` 标注的方法，编译器将报错。
- `void` 是一种数据类型，它代表「无返回值」。Java 中用数据类型来表达一个函数，它同时也表示了这个函数的返回值类型。对于 `void` 类函数来说，它们只负责「执行操作」而不返回任何值。

ps: 一般将放置在对象里的函数称为这个对象的**方法（method）**，被继承的类称为**父类（parent）**，继承父类的类称为**子类（child）**。
:::

一个标准的插件，应当拥有一个继承了 `JavaPlugin` 的主类，并且这个主类里有带有 `@Override` 注解的两个方法：`void onEnable` 和 `void onDisable`。它们的名称和调用方式是由 API 所规定的，并不能从外部更改，你可以将它看作为 API 作者为你开放的「打入插件的窗口」。

其中 `onEnable` 这个函数在插件被启用的时候会被调用，而 `onDisable` 则会在插件被禁用的时候被调用。如果一个插件本身没有问题，那么服务端在启动的时候就会自动启用这个插件，**于是 `onEnable` 也可以理解为在服务器启动的时候被调用。**

现在我们该如何写一个 Hello World 呢？其实上面的代码已经实现了这一点。根据上一段的解释，该插件在服务器启动的时候，会调用服务器的 Logger 输出一句 `MyPlugin is enabled.`；在服务器关闭的时候，会调用服务器的 Logger 输出一句 `MyPlugin is disabled.`。

:::warning
如果插件内部出现错误，服务端会强行禁用它，并显示出报错。此时，`onDisable` 也会被调用。
:::

具体的表现，大概是这样的：

```log{5}
...
[INFO] Preparing spawn area: 0%
[INFO] Time elapsed: 3849 ms
[INFO] [MyPlugin] Enabling MyPlugin v1.0-SNAPSHOT
[INFO] [MyPlugin] MyPlugin is enabled.   <-- 这里就是你的 Hello World!
[INFO] Running delayed init tasks
[INFO] Done (8.970s)! For help, type "help"
[INFO] Timings Reset
```

Hello World 已经完成了，在实际的插件制作过程中，主类有着怎样的作用呢？实际上，我们一般在主类里面做的事情有如下几种

- 一些初始化的工作
    - 配置文件
    - 需要用到的动态类
    - 与数据库的连接
- 显示一个欢迎的信息
- 其它工作

看上去似乎都是一些准备工作，但不要小看，它们实际上为整个插件的工作奠定了基础。一个最简单的插件是不带任何指令和事件的，换言之，最简单的插件就是这样一个主类，它没有任何其它的东西。显然，这样没有意义，因为我们的插件没有任何功能性可言。我们为了让插件具有功能性，自然要添加的就有**指令**，如果有需要的还可以添加**事件**。它们的详细概念和具体介绍将会分章节提及，在这里我们将简单介绍它们与主类的关系。

根据 API 的设定，指令、事件等若想要发挥作用，必须经过**注册**（或称设置，下面我们统称注册）。注册所调用的函数并不一样，但简单的过程概述就是——我们需要向一个特定的函数（也就是用来注册的函数）传入一个代表着我们的指令或者事件的对象。这个操作完成以后，我们就可以在游戏内执行指令，事件也可以发挥自己的作用。现在，我们需要思考

1. 帮助我们注册的函数是什么？
2. 传入的代表着指令或者事件的对象具体是什么？
3. 它们发挥作用的表现是什么？

我们先介绍注册函数。注册函数类似于一个工具，可以帮助我们把我们所写的有关指令和事件的定义「注册」到插件里去，让它们发挥作用。我们一般用到的注册函数有以下三个：

- `org.bukkit.plugin.PluginManager.registerEvents(@NotNull Listener listener, @NotNull Plugin plugin)`
- `org.bukkit.command.PluginCommand.setExecutor(@Nullable CommandExecutor executor)`
- `org.bukkit.command.PluginCommand.setTabCompleter(@Nullable TabCompleter completer)`

除此之外还有更多，例如 `org.bukkit.util.permissions.DefaultPermissions.registerPermission(String name, ...)`、`org.bukkit.plugin.PluginManager.registerInterface(@NotNull Class<? extends PluginLoader> loader)`，在此处仅解释这三个，平时插件的开发大多也只会用到这三个。它们的调用方法分别是

- `Bukkit.getPluginManager().registerEvents(事件监听类, 主类)`
- `Bukkit.getPluginCommand("指令").setExecutor(指令执行器类)`
- `Bukkit.getPluginCommand("指令").setTabCompleter(指令完成器类)`

在相应的位置填入相应的参数，即可完成注册；注册以后，它们都将发挥它们各自的功能。上述**事件监听类**（Event Listener）、**指令执行器类**（Command Executor）和**指令完成器类**（Tab Completer）分别就是我们所提到的「传入的代表着指令或者事件的对象」——没错，它们也是类。类比主类，它们也存在于自己的 `java` 文件中，也有各自的实现方法（因为继承或者实现了特定的接口），在下文我们会详细介绍它们。

## 事件监听类

要了解这个类，我们得首先知道什么叫做**事件（event）**，什么叫做**监听（listen）**。设想如下功能：如果我想要在挖完 10 个黑曜石以后，显示一条「10 Obsidians!」的信息，该怎么做？我们的直觉是在挖黑曜石的时候记录。那么我们怎么知道玩家是在挖东西，并且在挖黑曜石而不是在挖别的东西，以及黑曜石有没有掉落等等一系列的问题的答案呢？依靠事件。

我们在 Minecraft 世界里的一举一动实际上都在以事件的形式记录着，大到服务器加载地形，小到我们四处走动，每一分每一秒都有事件被**触发（fire）**。记录它们的原因很简单，营造丰富游戏体验的本质就是针对不同的事件给出特定的回应。侦测事件的行为叫做**监听**。下面，我们将在开发的角度熟悉事件的监听方法。

让我们先尝试实现一个当玩家加入游戏时，给玩家发送一条问候语 `Hello! <玩家名>` 的功能。

```java
package com.example.MyPlugin;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;

public final class MyEventListener implements Listener {
    @EventHandler
    public void onPlayerJoin(PlayerJoinEvent e) {
        Player p = e.getPlayer();
        p.sendMessage("Hello! " + p.getName());
    }
}
```

:::tip
**Java 语言讲堂 #2**

`implements <接口>` 表示当前的类**实现**（implements）了一个接口（不同于上面的 `extends` 继承）。实现一个接口和继承一个类有很大的肉眼不可见的差别，简单来说，

> 接口是一个模板，它规定了实现了这个接口的类应该放些什么东西；类是一个实体，继承它是为了拥有它先前的一切。

接口不包含任何实在的方法，而类包含。需要注意的是，`JavaPlugin` 这个类是一个 Abstract（抽象）类，抽象类的特点是至少含有一个抽象方法，抽象方法就是没有函数体的方法，相当于一个声明。抽象类由于并不需要真实的方法存在，在某种意义上和接口的概念是一样的，但也有区别。具体可以查看这里：[StackOverflow](https://stackoverflow.com/questions/10040069/abstract-class-vs-interface-in-java)。
:::

一个事件监听类首先需要实现一个 Listener 接口，相当于是在标记自己是一个监听类。要监听一个事件，请在监听类里添加一个 `public void` 方法，名称随意但必须有一个参数接受特定的事件，就像上面的 `PlayerJoinEvent`，正是这个参数的类型决定了此方法监听的事件。在上面的例子里，当 PlayerJoinEvent 被触发以后，`onPlayerJoin` 方法就会被调用。这就实现了事件监听的基本功能。

该方法被调用以后，首先 `Player p = e.getPlayer()` 获取了触发这个事件的玩家，然后调用了 `p.sendMessage(String msg)` 和 `p.getName()` 方法获取玩家的名称并向玩家发送信息。于是这样一个在玩家加入游戏以后就发送欢迎信息的插件就实现了...吗？

别急，我们还没有注册这个事件监听器！要注册它，请前往主类修改 `onEnable` 函数。

```java
// 别忘了 import！就算是自己写的，位于不同的文件也要 import。
import com.example.MyPlugin.MyEventListener;

// ...

@Override
public void onEnable() {
    // 前一个参数是 MyEventListener 实例，后一个参数是继承了 JavaPlugin 的主类实例。
    Bukkit.getPluginManager().registerEvents(new MyEventListener(), this);
}

// ...
```

这样，在插件启用的时候，事件监听器就会被自动注册，从注册时开始，事件监听就已开始。需要注意的是，虽然一个事件监听类里面可以有多个用来监听事件的方法，但应确保它们监听不同的事件，因为同一个事件在一个事件监听类里面只能出现一次，第二次将被忽略。

:::tip
**Java 语言讲堂 #3**
- **实例**（instance）是指一个类经过实例化（initialize）也就是 `new XXX()` 后的结果。例如如果「猫」是一个类，那么「实例化一个猫」就是让一个新的猫诞生的意思，这个新的猫具备自己的性格和特点，但它本质上是猫不变。
- `this` 代表当前的类实例。如果你想要在一个**非静态**（non-static）方法中调用当前的类，就需要使用 `this`。`this` 可以作为值传给需要当前的类实例的函数。如果要以静态的方式访问当前的类，直接写类的全称即可。

静态和非静态也是面向对象编程的基本概念，可以简单理解为：
> 静态的一切可以直接被外部调用，相当于是把已经写好的函数装在了「类」这个盒子里；非静态（也叫动态 dynamic）的一切需要进行实例化才能被调用，且调用的一切结果均是相对当前实例而言。

假设「狗」是一个类，它的实例化函数（也就是在实例化的时候调用的函数）接受一个参数 `name` 用来定义狗的名字，并且拥有一个方法 `String getName()` 来获取狗的名字。假设此时有狗 `a` 和 `b`，它们分别是这样被实例化的：`Dog a = new Dog('Wang'); Dog b = new Dog('WangWang')`，当我们执行它们的方法 `getName`，即 `a.getName(); b.getName()`，得到的结果就是 `Wang` 和 `WangWang`——所以说调用的一切结果均是相对当前实例而言。
:::

:::tip
**巧妙地找到自己需要的事件的名字**

在 Bukkit 类 API 中，事件有很多，各自代表的具体事件都不一样，但它们的命名格式都为 `XXXEvent`，前面的 XXX 用来描述这个事件。

如果你对英语稍有了解，就可以尝试着自己去搜索要用到的事件。例如想要实现一个玩家与村民对话的功能，那么就要考虑「玩家与实体互动」的事件，翻译成英文就是 `player interact entity`，随便一搜（在 Javadoc 中）就能得出两个结果：`PlayerInteractEntityEvent` 和 `PlayerInteractAtEntityEvent`，至于它们的具体区别，自行翻阅 Javadoc 即可了解，然后再按需取用即可。

但是此方法并不总是管用。例如 BlockBreakEvent，虽然它没有 Player 的字样，但是它的注释是 `Called when a block is broken by a player`。所以在了解到一个事件的存在以后，最好去查一下 Javadoc 了解正确的含义和用法。
:::

你可能会想：为什么玩家能够通过 `e.getPlayer()` 直接获得？玩家 `Player` 和事件 `XXXEvent` 之间有什么关联吗？实际上，**每一个事件里都包含了当前事件所牵涉到的大部分信息，可以通过 `getXX` 的方法获得**。PlayerJoinEvent 事件，字面意思就是「玩家加入的事件」，自然与玩家有关系，所以这个事件提供了 `getPlayer` 方法来让开发者获取到触发该事件的玩家。所有与玩家相关的事件都具有此方法。

不同的事件之间所包含的方法不一样。例如，BlockBreakEvent 在玩家破环方块的时候被触发，它就拥有一个 `getBlock` 方法，用于获取被破坏的方块信息。而这个方法很显然在与方块无关的事件上是没有理由存在的。以此类推，你可以自己找出某个事件所具有的方法，有的时候甚至不用专门查阅文档（如果你有代码提示的话）。

事件不仅有 `getXX`（获取）类方法，也有 `setXX`（设置）类方法。`set` 类方法用于改变一个事件本身——没错，你可以修改事件。

例如 BlockBreakEvent 上有一个 `setDropItems` 方法，它接受一个布尔值。当接收到的是 `false` 时，这个方块将不会掉落物品。这时，我们就修改了这个事件，使它违背了它原有的表现。修改事件可以帮助我们实现很多功能，例如只允许有某一种权限的人挖钻石矿掉落，其余的人都不掉落。

### `setCancelled` 和 `isCancelled`

几乎所有的事件都有一个 `setCancelled` 方法，它接受一个布尔值。同时也有一个 `isCancelled` 方法，它返回一个布尔值。

对于 `setCancelled`，当接收到的是 `true` 时，就取消当前事件。取消的效果是怎样的具体因事件而异。例如取消 BlockBreakEvent 的效果就是破坏的方块又复原且不掉落物品，相当于没有破坏；取消 PlayerMoveEvent 的效果就是玩家移动后又回到原地，相当于没有移动。至于为什么必须要先破坏再复原、先移动再回到原地，而不是直接无法破坏、无法移动，请参看 1.1 的[服务端](./1.1.md#服务端)环节。

有些事件并没有这两个方法，故它们是不可取消的。例如 PlayerJoinEvent 就不可取消，我们只能在玩家加入以后将他踢出，但不能阻碍玩家加入，道理是一样的。

:::tip
**`setCancelled` 和 `isCancelled` 与接口（Interface）概念的联系**

是什么让这么多的事件都具有这样的共性呢？实际上，所有拥有这两个方法的事件，都实现了接口 `Cancellable`（可取消的），而那些不能取消的事件便没有实现该接口。我们可以从这里感受到接口的含义——指导性的统一。
:::

## 指令执行器类

下面我们简称指令执行器类为指令执行器。

要了解这个类，我们首先要研究什么是**指令**（command）——我们也许早已经熟悉指令，但并不知道指令的本质是什么。实际上，Minecraft 指令是一个参数的集合，在程序中以字符串数组（也就是 `String[]`）的形式存在。例如指令 `/myplugin a b c d e` 放到程序里面，我们最终要针对它处理的数据就是 `["a", "b", "c", "d", "e"]` 这样一个数组。至于最前面的 `/myplugin`，`/` 代表这是一个指令而不是一个普通的消息（仅限游戏内），`myplugin` 表示这个指令所指向的插件。

如果一个指令找不到所指向的插件就会报错，因为没有可以**处理**（handle）这个指令的代码逻辑。我们注册一个指令执行器的目的就是让一个指令能够有一个处理者（handler），这个处理者就是指令执行器。观察我们注册时所调用的函数：

```java
Bukkit.getPluginCommand("myplugin").setExecutor(指令执行器);
```

如果用英语来理解它，就是在为一个 command 设置一个 executor，这个 executor 就是我们等一下要尝试写的指令执行器。在 `setExecutor` 之前，我们首先获取了这个指令，这一步骤我们是通过 `Bukkit.getPluginCommand(String name)` 来实现的。它接受一个字符串，这个字符串的内容就是一个指令开头的内容，也就是上文中的 `myplugin`。这一步让指令与执行器一一对应。

接下来我们来写一个执行器。一个执行器最基本的结构应该是这样的：