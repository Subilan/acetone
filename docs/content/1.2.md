# 我们的第一个插件

在 1.1 中我们了解了我们在编写插件时所要知道的一些基本概念和思想，现在，让我们正式展开插件的编写。这部分内容与 Java 本身紧密联系，对于一些特殊的概念将会加粗，然后在文中以插入块的形式具体讲解。

:::tip
为了后文的叙述清楚，我们在这里约定：
- 我们的插件名称叫做 `MyPlugin`
- 我们的插件包名为 `com.example.myPlugin`，因此我们的**主类**所在位置应当是 `/src/main/java/com/example/myPlugin`
- 我们的所有操作发生在 `/src/main/java/com/example/myPlugin` 内，并将此地址简记为 `@`
    - 例如，`@/MyPlugin.java` 则代表 `/src/main/java/com/example/myPlugin/MyPlugin.java`
- 我们的插件使用 Java 11 开发

除非声明，否则均按照此处所列信息看待。
:::

## 主类

**主类**是插件的起点。你也许听说过 C++ 里的 `int main()` 吧？那也是一个主类。主类可以认定为是整个程序的入口。那么既然它是主类，就必定有和其它「普通的类」有区别的地方——插件的主类继承了 `JavaPlugin` 这个接口（此处的接口为 Java 内部概念，与前文叙述的不一致）。

我们创建 `@/Main.java`，那么它的包名表达就是 `com.example.myPlugin.Main`，这就是本项目的主类在项目里的绝对表达，可以用于 `plugin.yml` 内对主类的设置。一个主类通常具有以下基本结构。

```java
// @/Main.java
package com.example.myPlugin; // 这里指定了当前文件所在的包，根据文件所在的位置会有所变化。

import org.bukkit.Bukkit; // 引入
import org.bukkit.plugin.java.JavaPlugin;

public final class Main extends JavaPlugin {
    @Override
    public void onEnable() {
        saveDefaultConfig();
        this.getLogger().info("MyPlugin is enabled.");
    }

    @Override
    public void onDisable() {
        this.getLogger().info("MyPlugin is disabled.");
    }
}
```

:::tip
**Java 语言讲堂 #1**

从这里开始，每相隔一两小节将会出现这样一个帮助你理解 Java 语言本身的小块，你可以选择性地阅读。内容不保证权威性，如需学习，请自行寻找专业教材，同时欢迎纠正。

- `package <包名>` 表达了当前文件所在的包，其与路径有关系。由于我们的 `Main.java` 放置在 `@` 下面，也就是 `/src/main/java`**`/com/example/myPlugin`** 这个目录下，所以包名写作 `com.example.myPlugin`。
    - 想一想：如果我将 `Main.java` 放置在 `@/Utils` 这个文件夹下面，包名应该写作什么？类比即可得出答案：`com.example.myPlugin.Utils`。**包名写错也是错。**
- `import <包名>` 导入了相应包下的类、接口等元素。例如，`org.bukkit` 是 `Bukkit` 这个类的包名，如果我们要导入 `Bukkit`，我们就可以用 `org.bukkit.Bukkit` 来代表它，然后 `import` 它即可使用。
- `public final class <类名>` 声明了一个终极公共类（其实不应该翻译成中文的😅）。其中 `public` 代表是「可以被外界访问的」，除此之外还有 `protected` 和 `private` 两种。主类只能为 `public`。而 `final` 则表示「最终的」，代表当前类不能被**继承**。实际上，如果没有相关需求，`final` 是否加上是没有影响的。我们一般把用这类形容词关键字 `public`、`final` 加上一个名词关键字例如 `class` 的行为称为**修饰**。例如我们可以说，这个类是被 `public final` 修饰的。不是什么高级概念，只是一种叫法。
- `extends <类/接口/...>` 继承指定的对象。这是面向对象编程的特色，具体的含义不在这里详细讲解。但你可以尝试从字面意义上理解，「继承」即代表享有被继承对象所具有的项目。而上面的 `final` 关键字可以防止某个对象被继承。
- `@Override` 是一个 Java Annotation（注解），除此之外还有 `@Deprecated` 等。它们相当于是可以影响编译行为的「小工具」。Override 单词本意是「覆盖」，在这里的意思是「覆盖父类的相关方法」。因为 `Main` 这个类继承了 `JavaPlugin`，加上 `@Override` 代表着在 `Main` 里面写的这个方法，`JavaPlugin` 里面也有同名的方法。如果父类中不存在被 `@Override` 标注的方法，编译器将报错。
- `void` 是一种数据类型，它代表「无返回值」。Java 中用数据类型来表达一个函数，它表示这个函数的返回值类型。对于 `void` 类函数来说，它们只负责「执行操作」而不返回任何值。

ps: 我们一般将放置在对象里的函数称为这个对象的**方法（method）**。
:::

一个标准的插件，应当拥有一个继承了 `JavaPlugin` 的主类，并且这个主类里有带有 `@Override` 注解的两个方法：`void onEnable` 和 `void onDisable`。其中 `onEnable` 这个函数在插件被启用的时候会被调用，而 `onDisable` 则会在插件被禁用的时候被调用。如果一个插件本身没有问题，那么服务端在启动的时候就会自动启用这个插件，于是 `onEnable` 也可以理解为在服务器启动的时候被调用。

那么现在我们该如何写一个 Hello World 呢？其实上面的代码已经实现了这一点。根据上一段的解释，该插件在服务器启动的时候，会调用服务器的 Logger 输出一句 `MyPlugin is enabled.`；在服务器关闭的时候，会调用服务器的 Logger 输出一句 `MyPlugin is disabled.`。

:::tip
如果插件内部出现错误，服务端会强行禁用它，并显示出报错。此时，`onDisable` 也会被调用。
:::

具体的表现，大概是这样的：

```log{5}
...
[INFO] Preparing spawn area: 0%
[INFO] Time elapsed: 3849 ms
[INFO] [MyPlugin] Enabling MyPlugin v1.0-SNAPSHOT
[INFO] [MyPlugin] MyPlugin is enabled.      <-- 这里就是你的 Hello World!
[INFO] Running delayed init tasks
[INFO] Done (8.970s)! For help, type "help"
[INFO] Timings Reset
```

我们 Hello World 算是写出来了，可是插件开发的思路呢？其实已经很显然了。主类作为整个插件的入口，由服务端主动调用，自然是要重点看待的。我们一般在主类里面做的事情有如下几种

- 一些初始化的工作
    - 配置文件
    - 需要用到的动态类
    - 与数据库的连接
- 显示一个「被启用」的信息
- 其它工作

也许你会想：这不全是在初始化吗？该怎样实现插件的内容呢？别着急，在后面我们介绍了一些基本功能以后，自然就会有思路了。

