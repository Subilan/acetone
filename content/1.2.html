<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>我们的第一个插件 | Acetone</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="以较快的方式了解 Minecraft 服务端插件开发">
    
    <link rel="preload" href="/assets/css/0.styles.fb41c43f.css" as="style"><link rel="preload" href="/assets/js/app.80f76160.js" as="script"><link rel="preload" href="/assets/js/2.ccae3753.js" as="script"><link rel="preload" href="/assets/js/3.df5561e6.js" as="script"><link rel="preload" href="/assets/js/11.3998030d.js" as="script"><link rel="prefetch" href="/assets/js/10.fafe178e.js"><link rel="prefetch" href="/assets/js/4.2f239b95.js"><link rel="prefetch" href="/assets/js/5.c44017b2.js"><link rel="prefetch" href="/assets/js/6.0bf1cba3.js"><link rel="prefetch" href="/assets/js/7.9f6e63f8.js"><link rel="prefetch" href="/assets/js/8.b38bb97e.js"><link rel="prefetch" href="/assets/js/9.c94b37f7.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fb41c43f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Acetone</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/about.html" class="nav-link">
  关于
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/about.html" class="nav-link">
  关于
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>入门</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/content/1.1.html" class="sidebar-link">1.1 插件的概念</a></li><li><a href="/content/1.2.html" aria-current="page" class="active sidebar-link">1.2 我们的第一个插件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/content/1.2.html#主类" class="sidebar-link">主类</a></li><li class="sidebar-sub-header"><a href="/content/1.2.html#事件监听类" class="sidebar-link">事件监听类</a></li><li class="sidebar-sub-header"><a href="/content/1.2.html#指令执行器类" class="sidebar-link">指令执行器类</a></li><li class="sidebar-sub-header"><a href="/content/1.2.html#指令完成器类" class="sidebar-link">指令完成器类</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="我们的第一个插件"><a href="#我们的第一个插件" class="header-anchor">#</a> 我们的第一个插件</h1> <p>在 1.1 中我们了解了我们在编写插件时所要知道的一些基本概念和思想，现在，让我们正式展开插件的编写。这部分内容与 Java 本身紧密联系，对于一些特殊的概念将会加粗，然后在文中以插入块的形式具体讲解。</p> <p>为了后文的叙述清楚，我们在这里约定：</p> <ul><li>我们的插件名称叫做 <code>MyPlugin</code></li> <li>我们的插件包名为 <code>com.example.myPlugin</code>，因此我们的<strong>主类</strong>所在位置应当是 <code>/src/main/java/com/example/myPlugin</code></li> <li>我们的所有操作发生在 <code>/src/main/java/com/example/myPlugin</code> 内，并将此地址简记为 <code>@</code> <ul><li>例如，<code>@/MyPlugin.java</code> 则代表 <code>/src/main/java/com/example/myPlugin/MyPlugin.java</code></li></ul></li> <li>我们的插件使用 Java 11 开发</li></ul> <p>除非声明，否则均按照此处所列信息看待。</p> <h2 id="主类"><a href="#主类" class="header-anchor">#</a> 主类</h2> <p><strong>主类</strong>是插件的起点。你也许听说过 C++ 里的 <code>int main()</code> 吧？那也是一个主类。主类可以认定为是整个程序的入口。那么既然它是主类，就必定有和其它「普通的类」有区别的地方——插件的主类继承了 <code>JavaPlugin</code> 这个接口（此处的接口为 Java 内部概念，与前文叙述的不一致）。</p> <p>接下来我们创建 <code>@/Main.java</code>，并将它看作主类，一个主类通常具有以下基本结构。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// @/Main.java</span>
<span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>myPlugin</span><span class="token punctuation">;</span> <span class="token comment">// 这里指定了当前文件所在的包，根据文件所在的位置会有所变化。</span>

<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>bukkit<span class="token punctuation">.</span></span><span class="token class-name">Bukkit</span><span class="token punctuation">;</span> <span class="token comment">// 引入</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>bukkit<span class="token punctuation">.</span>plugin<span class="token punctuation">.</span>java<span class="token punctuation">.</span></span><span class="token class-name">JavaPlugin</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token keyword">extends</span> <span class="token class-name">JavaPlugin</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">saveDefaultConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;MyPlugin is enabled.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDisable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;MyPlugin is disabled.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>Java 语言讲堂 #1</strong></p> <p>从这里开始，每相隔一两小节将会出现这样一个帮助你理解 Java 语言本身的小块，你可以选择性地阅读。内容不保证权威性，如需学习，请自行寻找专业教材，同时欢迎纠正。</p> <ul><li><code>package &lt;包名&gt;</code> 表达了当前文件所在的包，其与路径有关系。由于我们的 <code>Main.java</code> 放置在 <code>@</code> 下面，也就是 <code>/src/main/java/com/example/myPlugin</code> 这个目录下，所以包名写作 <code>com.example.myPlugin</code>。
<ul><li>想一想：如果我将 <code>Main.java</code> 放置在 <code>@/Utils</code> 这个文件夹下面，包名应该写作什么？类比即可得出答案：<code>com.example.myPlugin.Utils</code>。请注意：包名并不能随意地写。</li></ul></li> <li><code>import &lt;包名&gt;</code> 导入了相应包下的类、接口等元素。例如，<code>org.bukkit</code> 是 <code>Bukkit</code> 这个类的包名，如果我们要导入 <code>Bukkit</code>，我们就可以用 <code>org.bukkit.Bukkit</code> 来代表它，然后 <code>import</code> 它即可使用。</li> <li><code>public final class &lt;类名&gt;</code> 中 <code>public</code> 代表是「可以被外界访问的」，除此之外还有 <code>protected</code> 和 <code>private</code> 两种。主类只能为 <code>public</code> 类。<code>final</code> 表示「最终的」，即当前类不能被<strong>继承</strong>。实际上，如果没有相关需求，<code>final</code> 是否加上是没有影响的。</li> <li><code>extends &lt;类/接口/...&gt;</code> 继承指定的对象。这是面向对象编程的特色，具体的含义不在这里详细讲解。但你可以尝试从字面意义上理解，「继承」即代表享有被继承对象所具有的项目。上面的 <code>final</code> 关键字可以防止某个对象被继承。</li> <li><code>@Override</code> 是一个 Java Annotation（注解），除此之外还有 <code>@Deprecated</code> 等。它们相当于是可以影响编译行为的「小工具」。Override 单词本意是「覆盖」，在这里的意思是「覆盖父类的相关方法」。因为 <code>Main</code> 这个类继承了 <code>JavaPlugin</code>，所以在它内部的方法上面加上 <code>@Override</code> 就是在表明 <code>JavaPlugin</code> 这个父类里面也有同名的方法，并要用子类的方法去覆盖它。这样做可以保证接口被准确实现。如果父类中不存在子类中被 <code>@Override</code> 标注的方法，编译器将报错。</li> <li><code>void</code> 是一种数据类型，它代表「无返回值」。Java 中用数据类型来表达一个函数，它同时也表示了这个函数的返回值类型。对于 <code>void</code> 类函数来说，它们只负责「执行操作」而不返回任何值。</li></ul> <p>ps: 一般将放置在对象里的函数称为这个对象的<strong>方法（method）</strong>，被继承的类称为<strong>父类（parent）</strong>，继承父类的类称为<strong>子类（child）</strong>。</p></div> <p>一个标准的插件，应当拥有一个继承了 <code>JavaPlugin</code> 的主类，并且这个主类里有带有 <code>@Override</code> 注解的两个方法：<code>void onEnable</code> 和 <code>void onDisable</code>。它们的名称和调用方式是由 API 所规定的，并不能从外部更改，你可以将它看作为 API 作者为你开放的「打入插件的窗口」。</p> <p>其中 <code>onEnable</code> 这个函数在插件被启用的时候会被调用，而 <code>onDisable</code> 则会在插件被禁用的时候被调用。如果一个插件本身没有问题，那么服务端在启动的时候就会自动启用这个插件，<strong>于是 <code>onEnable</code> 也可以理解为在服务器启动的时候被调用。</strong></p> <p>现在我们该如何写一个 Hello World 呢？其实上面的代码已经实现了这一点。根据上一段的解释，该插件在服务器启动的时候，会调用服务器的 Logger 输出一句 <code>MyPlugin is enabled.</code>；在服务器关闭的时候，会调用服务器的 Logger 输出一句 <code>MyPlugin is disabled.</code>。</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>如果插件内部出现错误，服务端会强行禁用它，并显示出报错。此时，<code>onDisable</code> 也会被调用。</p></div> <p>具体的表现，大概是这样的：</p> <div class="language-log extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted"> </div><br><br><br><br></div><pre class="language-log"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token level info keyword">INFO</span><span class="token punctuation">]</span> <span class="token property">Preparing spawn area:</span> <span class="token number">0</span><span class="token operator">%</span>
<span class="token punctuation">[</span><span class="token level info keyword">INFO</span><span class="token punctuation">]</span> <span class="token property">Time elapsed:</span> <span class="token number">3849</span> ms
<span class="token punctuation">[</span><span class="token level info keyword">INFO</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>MyPlugin<span class="token punctuation">]</span> Enabling MyPlugin <span class="token number">v1.0</span><span class="token operator">-</span>SNAPSHOT
<span class="token punctuation">[</span><span class="token level info keyword">INFO</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>MyPlugin<span class="token punctuation">]</span> MyPlugin is enabled<span class="token punctuation">.</span>   <span class="token operator">&lt;</span><span class="token operator">-</span><span class="token operator">-</span> 这里就是你的 Hello World<span class="token operator">!</span>
<span class="token punctuation">[</span><span class="token level info keyword">INFO</span><span class="token punctuation">]</span> Running delayed init tasks
<span class="token punctuation">[</span><span class="token level info keyword">INFO</span><span class="token punctuation">]</span> Done <span class="token operator">(</span><span class="token number">8.970s</span><span class="token operator">)</span><span class="token operator">!</span> For help<span class="token punctuation">,</span> type <span class="token string">&quot;help&quot;</span>
<span class="token punctuation">[</span><span class="token level info keyword">INFO</span><span class="token punctuation">]</span> Timings Reset
</code></pre></div><p>Hello World 已经完成了，在实际的插件制作过程中，主类有着怎样的作用呢？实际上，我们一般在主类里面做的事情有如下几种</p> <ul><li>一些初始化的工作
<ul><li>配置文件</li> <li>需要用到的动态类</li> <li>与数据库的连接</li></ul></li> <li>显示一个欢迎的信息</li> <li>其它工作</li></ul> <p>看上去似乎都是一些准备工作，但不要小看，它们实际上为整个插件的工作奠定了基础。一个最简单的插件是不带任何指令和事件的，换言之，最简单的插件就是这样一个主类，它没有任何其它的东西。显然，这样没有意义，因为我们的插件没有任何功能性可言。我们为了让插件具有功能性，自然要添加的就有<strong>指令</strong>，如果有需要的还可以添加<strong>事件</strong>。它们的详细概念和具体介绍将会分章节提及，在这里我们将简单介绍它们与主类的关系。</p> <p>根据 API 的设定，指令、事件等若想要发挥作用，必须经过<strong>注册</strong>（或称设置，下面我们统称注册）。注册所调用的函数并不一样，但简单的过程概述就是——我们需要向一个特定的函数（也就是用来注册的函数）传入一个代表着我们的指令或者事件的对象。这个操作完成以后，我们就可以在游戏内执行指令，事件也可以发挥自己的作用。现在，我们需要思考</p> <ol><li>帮助我们注册的函数是什么？</li> <li>传入的代表着指令或者事件的对象具体是什么？</li> <li>它们发挥作用的表现是什么？</li></ol> <p>我们先介绍注册函数。注册函数类似于一个工具，可以帮助我们把我们所写的有关指令和事件的定义「注册」到插件里去，让它们发挥作用。我们一般用到的注册函数有以下三个：</p> <ul><li><code>org.bukkit.plugin.PluginManager.registerEvents(@NotNull Listener listener, @NotNull Plugin plugin)</code></li> <li><code>org.bukkit.command.PluginCommand.setExecutor(@Nullable CommandExecutor executor)</code></li> <li><code>org.bukkit.command.PluginCommand.setTabCompleter(@Nullable TabCompleter completer)</code></li></ul> <p>除此之外还有更多，例如 <code>org.bukkit.util.permissions.DefaultPermissions.registerPermission(String name, ...)</code>、<code>org.bukkit.plugin.PluginManager.registerInterface(@NotNull Class&lt;? extends PluginLoader&gt; loader)</code>，在此处仅解释这三个，平时插件的开发大多也只会用到这三个。它们的调用方法分别是</p> <ul><li><code>Bukkit.getPluginManager().registerEvents(事件监听类, 主类)</code></li> <li><code>Bukkit.getPluginCommand(&quot;指令&quot;).setExecutor(指令执行器类)</code></li> <li><code>Bukkit.getPluginCommand(&quot;指令&quot;).setTabCompleter(指令完成器类)</code></li></ul> <p>在相应的位置填入相应的参数，即可完成注册；注册以后，它们都将发挥它们各自的功能。上述<strong>事件监听类</strong>（Event Listener）、<strong>指令执行器类</strong>（Command Executor）和<strong>指令完成器类</strong>（Tab Completer）分别就是我们所提到的「传入的代表着指令或者事件的对象」——没错，它们也是类。类比主类，它们也存在于自己的 <code>java</code> 文件中，也有各自的实现方法（因为继承或者实现了特定的接口），在下文我们会详细介绍它们。</p> <h2 id="事件监听类"><a href="#事件监听类" class="header-anchor">#</a> 事件监听类</h2> <p>要了解这个类，我们得首先知道什么叫做<strong>事件（event）</strong>，什么叫做<strong>监听（listen）</strong>。设想如下功能：如果我想要在挖完 10 个黑曜石以后，显示一条「10 Obsidians!」的信息，该怎么做？我们的直觉是在挖黑曜石的时候记录。那么我们怎么知道玩家是在挖东西，并且在挖黑曜石而不是在挖别的东西，以及黑曜石有没有掉落等等一系列的问题的答案呢？依靠事件。</p> <p>我们在 Minecraft 世界里的一举一动实际上都在以事件的形式记录着，大到服务器加载地形，小到我们四处走动，每一分每一秒都有事件被<strong>触发（fire）</strong>。记录它们的原因很简单，营造丰富游戏体验的本质就是针对不同的事件给出特定的回应。侦测事件的行为叫做<strong>监听</strong>。下面，我们将在开发的角度熟悉事件的监听方法。</p> <p>让我们先尝试实现一个当玩家加入游戏时，给玩家发送一条问候语 <code>Hello! &lt;玩家名&gt;</code> 的功能。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span></span><span class="token class-name">MyPlugin</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>bukkit<span class="token punctuation">.</span></span><span class="token class-name">Bukkit</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>bukkit<span class="token punctuation">.</span>entity<span class="token punctuation">.</span></span><span class="token class-name">Player</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>bukkit<span class="token punctuation">.</span>event<span class="token punctuation">.</span></span><span class="token class-name">EventHandler</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>bukkit<span class="token punctuation">.</span>event<span class="token punctuation">.</span></span><span class="token class-name">Listener</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>bukkit<span class="token punctuation">.</span>event<span class="token punctuation">.</span>player<span class="token punctuation">.</span></span><span class="token class-name">PlayerJoinEvent</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">MyEventListener</span> <span class="token keyword">implements</span> <span class="token class-name">Listener</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@EventHandler</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPlayerJoin</span><span class="token punctuation">(</span><span class="token class-name">PlayerJoinEvent</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Player</span> p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">&quot;Hello! &quot;</span> <span class="token operator">+</span> p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>Java 语言讲堂 #2</strong></p> <p><code>implements &lt;接口&gt;</code> 表示当前的类<strong>实现</strong>（implements）了一个接口（不同于上面的 <code>extends</code> 继承）。实现一个接口和继承一个类有很大的肉眼不可见的差别，简单来说，</p> <blockquote><p>接口是一个模板，它规定了实现了这个接口的类应该放些什么东西；类是一个实体，继承它是为了拥有它先前的一切。</p></blockquote> <p>接口不包含任何实在的方法，而类包含。需要注意的是，<code>JavaPlugin</code> 这个类是一个 Abstract（抽象）类，抽象类的特点是至少含有一个抽象方法，抽象方法就是没有函数体的方法，相当于一个声明。抽象类由于并不需要真实的方法存在，在某种意义上和接口的概念是一样的，但也有区别。具体可以查看这里：<a href="https://stackoverflow.com/questions/10040069/abstract-class-vs-interface-in-java" target="_blank" rel="noopener noreferrer">StackOverflow<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p></div> <p>一个事件监听类首先需要实现一个 Listener 接口，相当于是在标记自己是一个监听类。要监听一个事件，请在监听类里添加一个 <code>public void</code> 方法，名称随意但必须有一个参数接受特定的事件，就像上面的 <code>PlayerJoinEvent</code>，正是这个参数的类型决定了此方法监听的事件。在上面的例子里，当 PlayerJoinEvent 被触发以后，<code>onPlayerJoin</code> 方法就会被调用。这就实现了事件监听的基本功能。</p> <p>该方法被调用以后，首先 <code>Player p = e.getPlayer()</code> 获取了触发这个事件的玩家，然后调用了 <code>p.sendMessage(String msg)</code> 和 <code>p.getName()</code> 方法获取玩家的名称并向玩家发送信息。于是这样一个在玩家加入游戏以后就发送欢迎信息的插件就实现了...吗？</p> <p>别急，我们还没有注册这个事件监听器！要注册它，请前往主类修改 <code>onEnable</code> 函数。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 别忘了 import！就算是自己写的，位于不同的文件也要 import。</span>
<span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span></span><span class="token class-name">MyPlugin<span class="token punctuation">.</span>MyEventListener</span><span class="token punctuation">;</span>

<span class="token comment">// ...</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 前一个参数是 MyEventListener 实例，后一个参数是继承了 JavaPlugin 的主类实例。</span>
    <span class="token class-name">Bukkit</span><span class="token punctuation">.</span><span class="token function">getPluginManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerEvents</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyEventListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ...</span>
</code></pre></div><p>这样，在插件启用的时候，事件监听器就会被自动注册，从注册时开始，事件监听就已开始。需要注意的是，虽然一个事件监听类里面可以有多个用来监听事件的方法，但应确保它们监听不同的事件，因为同一个事件在一个事件监听类里面只能出现一次，第二次将被忽略。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>Java 语言讲堂 #3</strong></p> <ul><li><strong>实例</strong>（instance）是指一个类经过实例化（initialize）也就是 <code>new XXX()</code> 后的结果。例如如果「猫」是一个类，那么「实例化一个猫」就是让一个新的猫诞生的意思，这个新的猫具备自己的性格和特点，但它本质上是猫不变。</li> <li><code>this</code> 代表当前的类实例。如果你想要在一个<strong>非静态</strong>（non-static）方法中调用当前的类，就需要使用 <code>this</code>。<code>this</code> 可以作为值传给需要当前的类实例的函数。如果要以静态的方式访问当前的类，直接写类的全称即可。</li></ul> <p>静态和非静态也是面向对象编程的基本概念，可以简单理解为：</p> <blockquote><p>静态的一切可以直接被外部调用，相当于是把已经写好的函数装在了「类」这个盒子里；非静态（也叫动态 dynamic）的一切需要进行实例化才能被调用，且调用的一切结果均是相对当前实例而言。</p></blockquote> <p>假设「狗」是一个类，它的实例化函数（也就是在实例化的时候调用的函数）接受一个参数 <code>name</code> 用来定义狗的名字，并且拥有一个方法 <code>String getName()</code> 来获取狗的名字。假设此时有狗 <code>a</code> 和 <code>b</code>，它们分别是这样被实例化的：<code>Dog a = new Dog('Wang'); Dog b = new Dog('WangWang')</code>，当我们执行它们的方法 <code>getName</code>，即 <code>a.getName(); b.getName()</code>，得到的结果就是 <code>Wang</code> 和 <code>WangWang</code>——所以说调用的一切结果均是相对当前实例而言。</p></div> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>巧妙地找到自己需要的事件的名字</strong></p> <p>在 Bukkit 类 API 中，事件有很多，各自代表的具体事件都不一样，但它们的命名格式都为 <code>XXXEvent</code>，前面的 XXX 用来描述这个事件。</p> <p>如果你对英语稍有了解，就可以尝试着自己去搜索要用到的事件。例如想要实现一个玩家与村民对话的功能，那么就要考虑「玩家与实体互动」的事件，翻译成英文就是 <code>player interact entity</code>，随便一搜（在 Javadoc 中）就能得出两个结果：<code>PlayerInteractEntityEvent</code> 和 <code>PlayerInteractAtEntityEvent</code>，至于它们的具体区别，自行翻阅 Javadoc 即可了解，然后再按需取用即可。</p> <p>但是此方法并不总是管用。例如 BlockBreakEvent，虽然它没有 Player 的字样，但是它的注释是 <code>Called when a block is broken by a player</code>。所以在了解到一个事件的存在以后，最好去查一下 Javadoc 了解正确的含义和用法。</p></div> <p>你可能会想：为什么玩家能够通过 <code>e.getPlayer()</code> 直接获得？玩家 <code>Player</code> 和事件 <code>XXXEvent</code> 之间有什么关联吗？实际上，<strong>每一个事件里都包含了当前事件所牵涉到的大部分信息，可以通过 <code>getXX</code> 的方法获得</strong>。PlayerJoinEvent 事件，字面意思就是「玩家加入的事件」，自然与玩家有关系，所以这个事件提供了 <code>getPlayer</code> 方法来让开发者获取到触发该事件的玩家。所有与玩家相关的事件都具有此方法。</p> <p>不同的事件之间所包含的方法不一样。例如，BlockBreakEvent 在玩家破环方块的时候被触发，它就拥有一个 <code>getBlock</code> 方法，用于获取被破坏的方块信息。而这个方法很显然在与方块无关的事件上是没有理由存在的。以此类推，你可以自己找出某个事件所具有的方法，有的时候甚至不用专门查阅文档（如果你有代码提示的话）。</p> <p>事件不仅有 <code>getXX</code>（获取）类方法，也有 <code>setXX</code>（设置）类方法。<code>set</code> 类方法用于改变一个事件本身——没错，你可以修改事件。</p> <p>例如 BlockBreakEvent 上有一个 <code>setDropItems</code> 方法，它接受一个布尔值。当接收到的是 <code>false</code> 时，这个方块将不会掉落物品。这时，我们就修改了这个事件，使它违背了它原有的表现。修改事件可以帮助我们实现很多功能，例如只允许有某一种权限的人挖钻石矿掉落，其余的人都不掉落。</p> <h3 id="setcancelled-和-iscancelled"><a href="#setcancelled-和-iscancelled" class="header-anchor">#</a> <code>setCancelled</code> 和 <code>isCancelled</code></h3> <p>几乎所有的事件都有一个 <code>setCancelled</code> 方法，它接受一个布尔值。同时也有一个 <code>isCancelled</code> 方法，它返回一个布尔值。</p> <p>对于 <code>setCancelled</code>，当接收到的是 <code>true</code> 时，就取消当前事件。取消的效果是怎样的具体因事件而异。例如取消 BlockBreakEvent 的效果就是破坏的方块又复原且不掉落物品，相当于没有破坏；取消 PlayerMoveEvent 的效果就是玩家移动后又回到原地，相当于没有移动。至于为什么必须要先破坏再复原、先移动再回到原地，而不是直接无法破坏、无法移动，请参看 1.1 的<a href="/content/1.1.html#服务端">服务端</a>环节。</p> <p>有些事件并没有这两个方法，故它们是不可取消的。例如 PlayerJoinEvent 就不可取消，我们只能在玩家加入以后将他踢出，但不能阻碍玩家加入，道理是一样的。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong><code>setCancelled</code> 和 <code>isCancelled</code> 与接口（Interface）概念的联系</strong></p> <p>是什么让这么多的事件都具有这样的共性呢？实际上，所有拥有这两个方法的事件，都实现了接口 <code>Cancellable</code>（可取消的），而那些不能取消的事件便没有实现该接口。我们可以从这里感受到接口的含义——指导性的统一。</p></div> <h2 id="指令执行器类"><a href="#指令执行器类" class="header-anchor">#</a> 指令执行器类</h2> <p>下面我们简称指令执行器类为指令执行器。</p> <p>要了解这个类，我们首先要研究什么是<strong>指令</strong>（command）——我们也许早已经熟悉指令，但并不知道指令的本质是什么。实际上，Minecraft 指令是一个参数的集合，在程序中以字符串数组（也就是 <code>String[]</code>）的形式存在。例如指令 <code>/myplugin a b c d e</code> 放到程序里面，我们最终要针对它处理的数据就是 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</code> 这样一个数组。最前面的 <code>/myplugin</code> 起着标示的作用：<code>/</code> 代表这是一个指令而不是一个普通的消息（仅限游戏内），<code>myplugin</code> 表示这个指令所指向的插件。</p> <p>如果一个指令找不到所指向的插件就会报错，因为没有可以<strong>处理</strong>（handle）这个指令的代码逻辑。我们注册一个指令执行器的目的就是让一个指令能够有一个处理者（handler），这个处理者就是指令执行器。观察我们注册时所调用的函数：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Bukkit</span><span class="token punctuation">.</span><span class="token function">getPluginCommand</span><span class="token punctuation">(</span><span class="token string">&quot;myplugin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setExecutor</span><span class="token punctuation">(</span>指令执行器<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>从英语的角度来理解，它是在为一个指令设置一个 executor，这个 executor 就是指令执行器。在 <code>setExecutor</code> 之前，我们首先获取了这个指令，这一步骤我们是通过 <code>Bukkit.getPluginCommand(String name)</code> 来实现的。它接受一个字符串，这个字符串的内容就是一个指令开头的内容，也就是上文中的 <code>myplugin</code>。这一步让指令与执行器一一对应。</p> <p>接下来我们来写一个执行器。一个执行器最基本的结构应该是这样的：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>sotap<span class="token punctuation">.</span></span><span class="token class-name">MissionTap<span class="token punctuation">.</span>Commands</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>bukkit<span class="token punctuation">.</span></span><span class="token class-name">Bukkit</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>bukkit<span class="token punctuation">.</span>command<span class="token punctuation">.</span></span><span class="token class-name">Command</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>bukkit<span class="token punctuation">.</span>command<span class="token punctuation">.</span></span><span class="token class-name">CommandExecutor</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>bukkit<span class="token punctuation">.</span>command<span class="token punctuation">.</span></span><span class="token class-name">CommandSender</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">CommandHandler</span> <span class="token keyword">implements</span> <span class="token class-name">CommandExecutor</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onCommand</span><span class="token punctuation">(</span><span class="token class-name">CommandSender</span> sender<span class="token punctuation">,</span> <span class="token class-name">Command</span> cmd<span class="token punctuation">,</span> <span class="token class-name">String</span> label<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// do something awesome</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它实现了一个 <code>CommandExecutor</code> 接口，该接口要求类必须有一个 <code>boolean onCommand</code> 方法用于处理指令。指令执行器相当于一个特殊的事件监听器，监听了一个特殊的指令执行的事件。<code>onCommand</code> 方法接受四个参数，分别为</p> <ul><li><code>CommandSender sender</code> — 指令的执行者。根据接口的继承情况可以判断，<code>CommandSender</code> 本质上是一个可以被赋予权限的任意对象。通常情况下执行指令的只有两类对象，一类是玩家，一类是控制台。</li> <li><code>Command cmd</code> — 代表指令的对象。你可以通过 <code>cmd.getName()</code> 获取到这个指令的全名。</li> <li><code>String label</code> — 代表执行指令时所使用的别名。它与 <code>cmd.getName()</code> 值可能不一样。</li> <li><code>String[] args</code> — 利用 <code>&quot; &quot;</code>（空格）分隔成的参数数组。</li></ul> <p>第一个参数的类 CommandSender 只能代表该指令的执行者，不一定是玩家或者控制台（还有可能是其它插件）。若要判断指令的执行者是玩家，可以通过 <code>instanceof</code> 实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 如果 sender 是一个 Player 实例</span>
<span class="token class-name">Player</span> p <span class="token operator">=</span> sender <span class="token keyword">instanceof</span> <span class="token class-name">Player</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token class-name">Player</span><span class="token punctuation">)</span> sender <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sender<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">&quot;指令只能由玩家执行。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// do more things here...</span>
</code></pre></div><p>这样就可以避免指令被控制台调用。这样做的原因有很多，比如有些指令需要通过执行该指令的玩家身上的信息返回结果，而控制台并不具备这些特性，因此这种指令不能由控制台执行。第二个参数代表当前的指令，它包含了这个指令的一些基本信息，比如 <code>String cmd.getName()</code> 获取指令名称、<code>List&lt;String&gt; cmd.getAliases()</code> 获取指令的所有别名、<code>String cmd.getDescription()</code> 获取指令的介绍信息等。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>离谱的巧合</strong></p> <p>今天笔者去读了一下 <a href="https://bdn.tdiant.net/#/unit/2-4?id=%e5%91%bd%e4%bb%a4%e6%89%a7%e8%a1%8c%e5%99%a8" target="_blank" rel="noopener noreferrer">Bukkit Development Note<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的相关部分，发现居然这部分的文章结构是一模一样的（用事件监听器来比拟、分别介绍每一个参数、介绍判断是否是玩家，甚至连破折号都是一样的，不过我习惯用一个破折号），太离谱了！上面各个参数的具体含义，我是翻类定义得知的，没想到写的也是差不多一样的内容😅</p> <p>因为不想推倒重写，在这里说明一下，避免误会，有兴趣的读者可以去读一下 BDN~</p></div> <p>对于第三个参数 <code>label</code>，它反映了该指令执行时所使用的别名。例如，如果你在 <code>plugin.yml</code> 里为你的指令设定了一个别名，假设为 <code>my</code>，那么在执行 <code>/my</code> 时 <code>label</code> 的值就是 <code>my</code>。当用全名 <code>myplugin</code> 来执行时，<code>label</code> 就是 <code>myplugin</code>。两种方法都会调用这个 <code>onCommand</code> 函数，但是对应的 <code>label</code> 值是不一样的。</p> <p>第四个参数 <code>args</code> 是一个指令发挥效用的核心。<code>args</code> 是一个字符串数组，它是由一个指令从第二位开始由空格分割的每一位所构成的。比如执行 <code>/myplugin a b c</code>，<code>args</code> 的值就是 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>。我们可以通过访问数组元素的方式访问每一个参数。例如 <code>args[0]</code> 代表的就是 <code>&quot;a&quot;</code>。接下来，我们简单实现一个指令，它的功能大致包含：</p> <ul><li><code>/myplugin hello &lt;玩家名&gt;</code> — 向一个玩家发送一条「Hello &lt;玩家名&gt;」的消息；</li> <li><code>/myplugin broadcast &lt;信息&gt;</code> — 广播一条信息；</li> <li><code>/myplugin help</code> — 显示该插件的帮助信息。</li></ul> <p>在这里我们发现，不同的 <code>args[0]</code> 体现了该指令的不同功能，于是不难想到用 <code>switch</code> 来实现。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">CommandHandler</span> <span class="token keyword">implements</span> <span class="token class-name">CommandExecutor</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onCommand</span><span class="token punctuation">(</span><span class="token class-name">CommandSender</span> sender<span class="token punctuation">,</span> <span class="token class-name">Command</span> cmd<span class="token punctuation">,</span> <span class="token class-name">String</span> label<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sender<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">&quot;请至少提供一个参数。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token string">&quot;hello&quot;</span><span class="token operator">:</span>
            <span class="token comment">// hello logic.</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>

            <span class="token keyword">case</span> <span class="token string">&quot;broadcast&quot;</span><span class="token operator">:</span>
            <span class="token comment">// broadcast logic.</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>

            <span class="token keyword">case</span> <span class="token string">&quot;help&quot;</span><span class="token operator">:</span>
            <span class="token comment">// help logic.</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>

            <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token comment">// default logic.</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过 <code>switch</code>，我们可以把不同的 <code>args[0]</code> 的值分入不同的分支，在这些分支里专门处理相关的内容，这是常见的参数利用方式之一。当玩家输入的指令的前半部分为 <code>/myplugin hello</code> 时，就会进入 <code>case &quot;hello&quot;:</code> 所在的分支，其它以此类推。</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p><strong>防范数组下标越界</strong></p> <p>Java 不是 JavaScript，并不会因为找不到就返回一个 <code>undefined</code> 了事。</p> <p>在 Java 中，数组的长度是固定的，这意味着任何超出数组长度的访问行为都是非法的，都会抛出错误，这个错误就是 <code>ArrayIndexOutOfBoundsException</code>。一个错误足以让插件停止运行，因此有必要防范。上面的代码中 <code>if (args.length == 0)</code> 就是在防范用户输入 <code>/myplugin</code> 而不带任何参数的情况，在这种情况下如果要获取 <code>args[0]</code>，自然会出现下标越界的错误。</p></div> <p>接下来，我们将以案例的形式实现各个部分的功能。这些案例与指令执行器本身无关，但它有助于你理解 API 中的<em>某些部分</em>。</p> <h4 id="案例-1-向玩家发送信息"><a href="#案例-1-向玩家发送信息" class="header-anchor">#</a> 案例 #1：向玩家发送信息</h4> <p>我们的指令的格式为 <code>/myplugin hello &lt;玩家名&gt;</code>，因此玩家名应该在 <code>args[1]</code> 的位置。具体实现如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// ...</span>
<span class="token keyword">case</span> <span class="token string">&quot;hello&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 避免参数不满足</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sender<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">&quot;请输入玩家名。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 这里的 return 语句提前结束了分支，下面的一切都不会被执行</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Player</span> target <span class="token operator">=</span> <span class="token class-name">Bukkit</span><span class="token punctuation">.</span><span class="token function">getPlayer</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sender<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">&quot;玩家不存在。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">isOnline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">&quot;Hello! &quot;</span> <span class="token operator">+</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">&quot;玩家不在线。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre></div><p>原来向玩家发送信息之前还有这么多的检查工作！</p> <p>首先，我们要检查参数的长度是否正常，避免下标越界。然后，我们要利用 API 提供的方法获取该玩家。可用的方法有 <code>Bukkit.getPlayer(String | UUID identifier)</code> 和 <code>&lt;plugin&gt;.getServer().getPlayer(String | UUID identifier)</code>，其中前者直接静态调用 <code>Bukkit</code> 的方法，后者需要从主类的实例上调用。根据 API 的描述，如果玩家不存在，此方法将返回 <code>null</code>，所以我们也要确保玩家输入的 ID 获取到的玩家是存在的，即确保此方法的返回值不为 <code>null</code>，如果是 <code>null</code> 则提醒玩家，目标玩家不存在。</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p><strong>防范空指针异常</strong></p> <p>空指针异常，也就是 <code>NullPointerException</code>，相信是最为普遍的错误了，根本原因是把 <code>null</code> 的值带到了不该有 <code>null</code> 的地方。为什么会有这么多空指针错误呢？因为在 Java 编程中，一个方法返回 <code>null</code> 的情况很常见，而且还存在 <code>Objects.requireNonNull(Object obj)</code> 这种方法（这个方法如果发现传入对象是 <code>null</code> 就会抛出 NPE），导致一旦处理不好，NPE 随时有可能出现。</p> <p>NPE 的棘手之处在于，如果不经过排查或者熟悉，你很难知道到底是哪个地方出现了 <code>null</code>。因此在写程序的时候，时刻思考 <code>null</code> 并提防 <code>null</code> 很重要！</p></div> <p>最后，我们需要调用 Player 实例上的方法 <code>boolean isOnline</code> 来判断该玩家是否在线，如果在线则调用 <code>void sendMessage(String msg)</code> 向对方发送一个 <code>Hello! &lt;玩家名&gt;</code> 的信息。</p> <h4 id="案例-2-让服务器广播信息"><a href="#案例-2-让服务器广播信息" class="header-anchor">#</a> 案例 #2：让服务器广播信息</h4> <p>服务器广播信息与向用户发送信息的本质区别是，一个全服的人包括控制台都看得见信息，一个只有用户自身可以看得见信息，控制台能看到记录。后者通过 <code>Player.sendMessage(String msg)</code> 方法可实现，前者通过 <code>&lt;plugin&gt;.getServer().broadcast(String msg, String permission)</code> 和 <code>&lt;plugin&gt;.getServer().broadcastMessage(String msg)</code> 可实现。注意 <code>&lt;plugin&gt;.getServer()</code> 是从主类实例调用的，也可以替换成 <code>Bukkit</code> 来静态调用。</p> <ul><li><code>broadcast(String msg, String permission)</code> — 向所有具有 <code>permission</code> 的值所指的权限节点对应的权限的玩家广播信息。</li> <li><code>broadcastMessage(String msg)</code> — 向全服的玩家广播信息。</li></ul> <p>我们在这里使用第二个方法。于是案例可以这样写：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// ...</span>
<span class="token keyword">case</span> <span class="token string">&quot;broadcast&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sender<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">&quot;请输入信息内容。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Bukkit</span><span class="token punctuation">.</span><span class="token function">broadcastMessage</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这回很简单，只用做一个验证。</p> <h4 id="案例-3-显示一个插件的指令帮助"><a href="#案例-3-显示一个插件的指令帮助" class="header-anchor">#</a> 案例 #3：显示一个插件的指令帮助</h4> <p>指令帮助在插件内很常见，几乎所有的插件都有一个专门的帮助页面。帮助页面的本质是向指令执行者发送的一连串固定的（提前写好的）信息。我们可以这样写：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// ...</span>
<span class="token keyword">case</span> <span class="token string">&quot;help&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    sender<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">&quot;MyPlugin 指令帮助&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sender<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">&quot;/myplugin hello &lt;玩家名&gt; — 向指定玩家发送 Hello! 信息&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sender<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">&quot;/myplugin broadcast &lt;信息&gt; — 全服广播信息&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sender<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">&quot;/myplugin help — 查看帮助页面&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是这样的帮助页面似乎显得很单调，因为没有了颜色的加持，显示在游戏里都是白色。对于颜色和格式代码的介绍，将放在后面的一章内讲解，敬请期待。</p> <p>也许因为我们这个插件的功能很简单，所以要写的帮助文本不是很多。那么如果将来的指令变得很多，都要一行一行地 <code>sendMessage</code> 吗？并不是，我们可以用循环来帮助我们发送信息，这样我们只需要写一行 <code>sendMessage</code>。大体思路如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// ...</span>
<span class="token keyword">case</span> <span class="token string">&quot;help&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> helpTexts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
        <span class="token string">&quot;我是第一行文本&quot;</span><span class="token punctuation">,</span>
        <span class="token string">&quot;我是第二行文本&quot;</span><span class="token punctuation">,</span>
        <span class="token string">&quot;我是第三行文本&quot;</span><span class="token punctuation">,</span>
        <span class="token comment">// ...</span>
        <span class="token string">&quot;我是第 N 行文本&quot;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> t <span class="token operator">:</span> helpTexts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sender<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>Java 语言讲堂 #4</strong></p> <p>Java 中的 <code>for</code> 循环有三种形式：</p> <ul><li>普通 — <code>for (def; term; incr) {}</code> 第一个参数为定义，第二个参数为终止条件，第三个参数为自增操作。</li> <li>无限循环 — <code>for ( ; ; ) {}</code> 没有定义，没有终止，没有自增。</li> <li>增强（enhanced）循环（遍历）— <code>for (def : target)</code> 第一个参数为定义，中间为冒号 <code>:</code>，第二个参数为遍历对象（对象必须是<strong>可遍历的</strong>（Iterable），例如 <code>List</code>、数组等都可以被遍历）</li></ul> <p>第三种形式就是上面我们所使用的，它是在这种需求下所建议使用的方法。它等价于传统的 <code>for (int i = 0; i &lt; target.length; i++)</code>。</p></div> <p>这里我们用到了 Java 的 enhanced for 循环，它遍历 <code>helpTexts</code> 这个字符串数组。我们在这个数组里写几行，它都会一次次遍历并用 <code>sendMessage</code> 发出去，因此我们在添加内容时，只需要对数组做出改动而不再需要改动下面的输出代码了，比上面的好几行 <code>sendMessage</code> 要简洁不少。</p> <h2 id="指令完成器类"><a href="#指令完成器类" class="header-anchor">#</a> 指令完成器类</h2> <p>下面我们简称指令完成器类为指令完成器。</p> <p>指令完成器主要用于为一个指令添加自动补全功能。自动补全在游戏内可以通过在键入指令时按下 <kbd>tab</kbd> 键来实现。指令完成器类的本质也是一个事件监听器，与指令执行器不同，指令完成器监听的 TabComplete 这样一个事件。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>指令的自动补全功能是在 Minecraft Java 版 1.12 加入的。</p></div> <p>要注册指令完成器，可以在 Command 实例上调用方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Bukkit</span><span class="token punctuation">.</span><span class="token function">getPluginCommand</span><span class="token punctuation">(</span><span class="token string">&quot;myplugin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setTabCompleter</span><span class="token punctuation">(</span>指令完成器<span class="token punctuation">)</span>
</code></pre></div><p>一个指令完成器的基本结构如下：</p> <div class="language-java extra-class"><pre class="language-java"><code>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Tab</span> <span class="token keyword">implements</span> <span class="token class-name">TabCompleter</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> COMPLETION <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">onTabComplete</span><span class="token punctuation">(</span><span class="token class-name">CommandSender</span> sender<span class="token punctuation">,</span> <span class="token class-name">Command</span> command<span class="token punctuation">,</span> <span class="token class-name">String</span> alias<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>command<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">&quot;myplugin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// result.add(xxx)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>指令完成器实现了 <code>TabCompleter</code> 接口，该接口要求 Override 一个 <code>List&lt;String&gt; onTabComplete</code> 方法。由于该方法返回值是 <code>List&lt;String&gt;</code>，所以我们需要在方法的开头初始化一个 <code>List&lt;String&gt;</code> 的结果变量 <code>result</code>。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>Java 语言讲堂 #5</strong></p> <p>List 是 Java 中的一种可以动态修改的数组，分为 ArrayList（数组）和 LinkedList（链表）两种。前者的使用较为广泛，多用于只需要在末尾添加或删除元素的情况；后者的查找与修改效率较低，但在所有位置添加和删除的效率较高。</p> <p>要开始使用 List，必须先进行初始化，即创建一个 List 实例。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 限定为 ArrayList： ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="token comment">// 同时指定类型：List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="token comment">// 另一种推断：var result = new ArrayList&lt;String&gt;();</span>
</code></pre></div><p>通用形式 <code>List&lt;T&gt; a = new ArrayList&lt;T?&gt;();</code>，T 处填写泛型数据类型。如果前面填写了后面可以不填，写成 <code>&lt;&gt;</code>（被称为「钻石 diamond」）；如果前面用 <code>var</code> 后面必须指定。链表以此类推即可。</p></div> <p>我们在这个结果变量里添加的内容，就是返回到用户执行的指令的自动补全里的内容。在 1.13 以后，指令自动补全的结果会在一个黑框内显示。</p> <p>很显然，上面的结构并不能实现功能，总感觉缺了点什么。在实现这一切之前，我们需要先看清楚一个指令是如何被自动补全的。首先，我们输入这个指令的全名：</p> <div class="language- extra-class"><pre class="language-text"><code>/mypl
    ^
</code></pre></div><p><em>用 <code>^</code> 代指光标所在位置</em></p> <p>此时会有一个由服务端提供的自动补全，帮助你补全指令的全名。它获取了所有已经注册的指令和别名。这样的补全有如下特点：</p> <ul><li>根据已经输入的内容进行补全。例如输入 <code>m</code>，那么只会继续补全以 <code>m</code> 开头的内容；输入 <code>my</code>，那么只会继续补全以 <code>my</code> 开头的内容，以此类推。</li> <li>补全的内容都是已经被认定为可用的。</li></ul> <p>因此，要实现我们插件的补全，也要达成上面两项要求。以下展示了达成上面两项要求的代码。</p> <div class="language-java extra-class"><pre class="language-java"><code>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Tab</span> <span class="token keyword">implements</span> <span class="token class-name">TabCompleter</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ARG_0_COMPLETION <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&quot;broadcast&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;help&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hello&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">getAvailableCommands</span><span class="token punctuation">(</span><span class="token class-name">Player</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> available <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> cmd <span class="token operator">:</span> ARG_0_COMPLETION<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">hasPermission</span><span class="token punctuation">(</span><span class="token string">&quot;myplugin.&quot;</span> <span class="token operator">+</span> cmd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                available<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> available<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token class-name">String</span> arg<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> commands<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">StringUtil</span><span class="token punctuation">.</span><span class="token function">copyPartialMatches</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> commands<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">onTabComplete</span><span class="token punctuation">(</span><span class="token class-name">CommandSender</span> sender<span class="token punctuation">,</span> <span class="token class-name">Command</span> command<span class="token punctuation">,</span> <span class="token class-name">String</span> alias<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            result <span class="token operator">=</span> <span class="token function">getResult</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">getAvailableCommands</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Player</span><span class="token punctuation">)</span> sender<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>变得复杂多了。但是通过我们的解释，你仍然能够理解它的每一部分都是干什么的。我们依然从 <code>onTabComplete</code> 看起。</p> <p>首先，它初始化了一个变量 <code>List&lt;String&gt; result</code> 作为自动补全的结果变量。然后有一个判断 <code>if (args.length == 1)</code>，这一步是为了干什么呢？这实际上是在<strong>确定当前所补全的参数位置</strong>。<code>onTabComplete</code> 这个函数基本上每在指令中打一个字，就会被执行一次，因此 <code>args.length</code> 也是随时改变的。如果 <code>args.length == 1</code> 返回 <code>true</code>，就代表当前处于第一个参数的位置，我们就可以得知要补全第一个参数。</p> <p>接下来对 <code>result</code> 赋值，调用了一个 <code>getResult(String, List&lt;String&gt;)</code> 函数和 <code>getAvailableCommands(Player)</code> 函数。我们接下来详细介绍这两个函数。</p> <h4 id="getavailablecommands-player"><a href="#getavailablecommands-player" class="header-anchor">#</a> <code>getAvailableCommands(Player)</code></h4> <p>该函数用于获取对一个玩家可用的补全项，用来满足我们上文中提到的条件二</p> <blockquote><p>补全的内容都是已经被认定为可用的。</p></blockquote> <p>我们补全的应当是对当前用户可用的内容。可用的决定是多因素的，我们在这里只考虑权限因素。如果用户没有相应的权限，自然也没必要补全这一项，因此我们需要使用这个函数，先针对一个 <code>Player</code> 获取他所能使用的项目，然后返回。这相当于是一层筛选。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">getAvailableCommands</span><span class="token punctuation">(</span><span class="token class-name">Player</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> available <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> cmd <span class="token operator">:</span> ARG_0_COMPLETION<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">hasPermission</span><span class="token punctuation">(</span><span class="token string">&quot;myplugin.&quot;</span> <span class="token operator">+</span> cmd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            available<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> available<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实很好理解，先创建一个 <code>available</code> 用来存储结果并返回，然后利用 enhanced for 来遍历 <code>ARG_0_COMPLETION</code>。<code>ARG_0_COMPLETION</code> 是我们手动填写的，针对 <code>args[0]</code>（也就是参数的第一个位置）的所有补全内容，以 <code>final String[]</code> 的形式放置在 Tab 类里面。</p> <p>遍历的目的是筛选玩家有权限的部分。判断 <code>if (p.hasPermission(&quot;myplugin.&quot; + cmd))</code>，如果是则添加到 <code>available</code> 结果变量里，最终返回。如果没有符合的，最终返回的将是一个空的 <code>List</code>（千万不能返回一个 <code>null</code> 了事！）。</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p><code>p.hasPermission(&quot;myplugin.&quot; + cmd)</code> 这种判断方式，仅适用于已经在 <code>plugin.yml</code> 按照此种格式（即 <code>myplugin.参数名</code>）定义了相应权限的情形，这也是较为简便的处理方式，但不止这一种。</p></div> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>遍历的高级写法</strong></p> <p>遍历、判断再添加是一种较为传统的方式，其实还有下面这些较为高级的写法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 一行解决，推荐</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> available <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>ARG_0_COMPLETION<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> p<span class="token punctuation">.</span><span class="token function">hasPermission</span><span class="token punctuation">(</span><span class="token string">&quot;myplugin.&quot;</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// lambda</span>
<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>ARG_0_COMPLETION<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">hasPermission</span><span class="token punctuation">(</span><span class="token string">&quot;myplugin.&quot;</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        available<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></div> <h4 id="getresult-string-list-string"><a href="#getresult-string-list-string" class="header-anchor">#</a> <code>getResult(String, List&lt;String&gt;)</code></h4> <p>该函数用来获取最终的结果，第一个参数是当前的参数 <code>args[0]</code>，第二个参数是经过筛选以后的补全值数组。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token class-name">String</span> arg<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> commands<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">StringUtil</span><span class="token punctuation">.</span><span class="token function">copyPartialMatches</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> commands<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先还是初始化了一个 <code>result</code>，然后利用 <code>StringUtil.copyPartialMatches(arg, commands, result)</code> 来为 <code>result</code> 赋值。这一步主要完成的是<strong>根据当前的输入情况从 <code>commands</code> 中抽取部分匹配的部分复制到 <code>result</code> 中</strong>。例如</p> <div class="language- extra-class"><pre class="language-text"><code>/myplugin broa
             ^
</code></pre></div><p>由于每打一个字，<code>onTabComplete</code> 都会被执行一次，所以 <code>args[0]</code> 时刻反映当前位于参数位第一位的值。</p> <p>因此，当我们输入到这里时，<code>args[0]</code> 的值实际上是 <code>broa</code> 四个字母。将这四个字母输入到此函数中作为第一个参数，那么 <code>StringUtil.copyPartialMatches</code> 就会从此函数的第二个参数 <code>commands</code>（假设为 <code>{&quot;broadcast&quot;, &quot;help&quot;, &quot;hello&quot;}</code>）中抽取包含 <code>broa</code> 的部分，也就是 <code>broadcast</code> 这个元素，将它放到 <code>StringUtil.copyPartialMatches</code> 接受的第三个参数 <code>result</code> 中。因此这个时候 <code>result</code> 就包含一项内容 <code>broadcast</code>，最终将该内容返回到我们刚开始的地方，作为 <code>onTabComplete</code> 函数的输出，完成补全。</p> <p>在这里我们就实现了我们提到的要求中的第一条</p> <blockquote><p>根据已经输入的内容进行补全。例如输入 <code>m</code>，那么只会继续补全以 <code>m</code> 开头的内容；输入 <code>my</code>，那么只会继续补全以 <code>my</code> 开头的内容，以此类推。</p></blockquote> <p>下一句 <code>Collections.sort(result)</code> 在对内容进行整理，例如字母排序等，为了让内容多的时候更加整齐划一。在这里由于我们举得例子里面的参数比较少，所以这一句没有什么明显的效果。</p> <p>以上就是一个指令完成器的基本实现，借助该实现里的方法，你可以写关于 <code>args[1]</code>、<code>args[2]</code> 的补全来适应更加复杂的指令，不过一般用不到那里。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>把指令执行器与完成器相结合</strong></p> <p>Bukkit API 提供了一个接口 <code>TabExecutor</code> 用来方便同时实现 <code>TabCompleter</code> 和 <code>CommandExecutor</code>。也就是说，你可以选择只让一个类实现 <code>TabExecutor</code> 这个接口，然后在这个类里面同时 Override <code>onCommand</code> 和 <code>onTabComplete</code>，一样可以达到效果。在注册的时候，两个地方填写同样的实例即可。</p></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/content/1.1.html" class="prev">
        1.1 插件的概念
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.80f76160.js" defer></script><script src="/assets/js/2.ccae3753.js" defer></script><script src="/assets/js/3.df5561e6.js" defer></script><script src="/assets/js/11.3998030d.js" defer></script>
  </body>
</html>
