<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1.1 插件的概念 | Acetone</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="以较快的方式了解 Minecraft 服务端插件开发">
    
    <link rel="preload" href="/assets/css/0.styles.fb41c43f.css" as="style"><link rel="preload" href="/assets/js/app.770deb9e.js" as="script"><link rel="preload" href="/assets/js/2.ccae3753.js" as="script"><link rel="preload" href="/assets/js/3.df5561e6.js" as="script"><link rel="preload" href="/assets/js/10.abbb295a.js" as="script"><link rel="prefetch" href="/assets/js/11.6d71b313.js"><link rel="prefetch" href="/assets/js/4.2f239b95.js"><link rel="prefetch" href="/assets/js/5.c44017b2.js"><link rel="prefetch" href="/assets/js/6.0bf1cba3.js"><link rel="prefetch" href="/assets/js/7.9f6e63f8.js"><link rel="prefetch" href="/assets/js/8.b38bb97e.js"><link rel="prefetch" href="/assets/js/9.c94b37f7.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fb41c43f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Acetone</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/about.html" class="nav-link">
  关于
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/about.html" class="nav-link">
  关于
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>入门</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/content/1.1.html" aria-current="page" class="active sidebar-link">1.1 插件的概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/content/1.1.html#接口" class="sidebar-link">接口</a></li><li class="sidebar-sub-header"><a href="/content/1.1.html#服务端" class="sidebar-link">服务端</a></li><li class="sidebar-sub-header"><a href="/content/1.1.html#插件" class="sidebar-link">插件</a></li></ul></li><li><a href="/content/1.2.html" class="sidebar-link">1.2 我们的第一个插件</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_1-1-插件的概念"><a href="#_1-1-插件的概念" class="header-anchor">#</a> 1.1 插件的概念</h1> <h2 id="接口"><a href="#接口" class="header-anchor">#</a> 接口</h2> <p>你是否思考过什么叫做<strong>插件（plugin）</strong>？</p> <p>从英文角度来理解，<code>plugin</code> 实际上是一个合成词，它原本指的是一个动作，即 <code>plug in</code>，因而该名词也可以写成复合形式 <code>plug-in</code>。Plug in 这个动作，可以理解为把插头插进插座里；将这个动作抽象化、名词化以后，就出现了「插件」的概念——它是一个半路插入的中间物件。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>下文中的插件均指 Minecraft 服务端插件。</p></div> <p>插件作为半路插入的东西，游戏本身并没有它。开发者通过向插件内添加代码，来使它对游戏起到一定的拓展与改变作用。你是否想过，究竟是什么能让一个不是游戏原作者写的程序控制这款游戏？那就是<strong>应用程序接口（application programming interface, <em>abbr.</em> API）</strong>，在本文中简称<strong>接口（interface）</strong>。接口有很多种，它们相互之间的概念也并不重合。在本文中，我们的接口都是指「将 Minecraft 本体与插件衔接起来的中间体」。</p> <p>接口是凭空产生的吗？并不是，接口是需要人为编写的。接口本质上是一种约定，约定你应该以怎样的方式与主程序沟通。只要在学会 Java 语言的基础上了解接口，就可以顺利地写插件。接口就好比语言中的方言，你到达了一个小地方，想要和那里的人沟通，就必须了解当地的方言——而如果你只会普通话，有可能根本无法和他们沟通。</p> <p>Minecraft 的接口并不是由官方所创造的。也许你早已听说过官服与「水桶服」的区别——一个不能加插件，一个可以加插件，道理也就在这里。水桶服是由开发者自行拓展出来的一份接口所形成的服务器，它是在官服的基础上加以修改的结果。这些「修改的结果」就是形形色色的服务端，它们的源头都是官服，下面我们来详细介绍一下服务端的概念。</p> <h2 id="服务端"><a href="#服务端" class="header-anchor">#</a> 服务端</h2> <p>接口是由服务端所提供的（更严格地说，是由服务端和插件共同实现的），如果你按照接口的规定写代码，并且按照约定放在了服务端生成的 <code>plugins</code> 文件夹下面，那么你的插件就可以与服务端建立沟通，服务端就可以将你的插件应用到玩家所看到的世界里。服务端究竟是一个怎样的存在？</p> <p>一个完整的服务器游戏体验，分为<strong>客户端</strong>和<strong>服务端</strong>两个部分，在许多计算机软件中也是这样。客户端就是 Minecraft 游戏本体，你可以在客户端中选择「多人游戏」去连接一个服务器。所谓「服务器」本质指的就是服务端。服务端是一个「请求处理者」，本质上它提供的只是对玩家在服务器中几乎所有的行为的反应，而游戏本身的体验依然是由客户端决定。</p> <p>这句话的意思是，游戏本身的所有体验都是由客户端提供的，玩家在多人模式下的所有行为本应和单人模式下的一致，而多人模式与单人模式的本质区别就是多人模式会将玩家的一举一动都发送给服务器，这个发送的对象就是服务端，服务端根据这些数据返回相应的回应数据，这样多人游戏体验就建立了。</p> <p>于是我们可以归纳出，<strong>进入服务器进行游戏的本质是客户端发送请求、服务端处理请求和发送回应、客户端接收回应并处理回应的过程</strong>，这里的请求指的是某种形式的数据。</p> <p>例如，进入服务器首先需要加载地形，地形的数据就是由服务端发来的（因为地图存档并不在你的电脑上，这是一个服务器的基本特征）。客户端依据发来的数据开始加载本地的地形以让玩家看到，这样一个世界就形成了。玩家的每一次移动、每一句聊天指令等，均会发往服务端，服务端也会将结果发送回来。细心的读者可以想到，在这里服务端和客户端之间一定也存在着某种「约定」，因为只有这样客户端才能读懂服务端发回的数据以及发送服务端可以读懂的数据。</p> <p>于是这里我们引用 tdiant 大佬在 <a href="https://bdn.tdiant.net/#/unit/2-2?id=%e7%90%86%e8%a7%a3%e5%ae%a2%e6%88%b7%e7%ab%af%e4%b8%8e%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%9a%84%e5%85%b3%e7%b3%bb" target="_blank" rel="noopener noreferrer">Bukkit Development Note<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 中提到的一个例子。为什么领地插件在禁止你走动的时候，你往往是动了以后又回到原位，而不是根本不能动呢？这是因为「走动」是一种客户端行为（任何游戏本体的操作都是客户端行为），在服务器这个特殊环境里，客户端需要将玩家的一举一动都发往服务端，而在客户端发往服务端，并未收到请求的时候，这些行为并不会被处理（按照本地游戏的方式表现出来，走了就是走了），而当服务端通过插件的代码得出结论，返回一个「禁止走动」的回应时，客户端就会取消「走动」这个动作，玩家也就会回到原本的地方，<strong>相当于没有走动</strong>。</p> <p>我们应该可以给服务端下定义了：<strong>Minecraft 服务端是处理 Minecraft 多人游戏的远程终端，它负责控制整个多人模式下的游戏，根据客户端发送的数据进行处理并返回对应的结果</strong>。我们要理解的重点是，不同的服务端提供了不同的插件运行载体，也向插件提供了不同的接口。</p> <p>下面，我们就来简单地认识不同的服务端及其对应的接口。</p> <h3 id="官服"><a href="#官服" class="header-anchor">#</a> 官服</h3> <p>官方只推出过一种服务端，一般称之为官服，在英文中习惯称之为 <strong>Vanilla</strong>。官服不提供对外的接口，意思是你没有办法把插件放到官服里去运行。在运行的时候你会发现，目录下并没有生成名为 <code>plugins</code> 的文件夹。</p> <h3 id="bukkit-spigot-和-paper"><a href="#bukkit-spigot-和-paper" class="header-anchor">#</a> Bukkit，Spigot 和 Paper</h3> <p>这三者是<strong>插件服务器</strong>中的主流服务端，但 Bukkit 考虑性能问题已经很少有人使用。这三者是 Acetone 所要讲述的重点，他们彼此之间存在着密切的联系。到底是什么联系呢？</p> <p>实际上，Spigot 是 Bukkit 的 <strong>fork（派生）</strong>，Paper（也叫 Paper Spigot）是 Spigot 的 fork。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>Fork</strong> 这个动作可以通俗地理解为「在原有的基础上再开发」。也就是说，Spigot 是在 Bukkit 的代码上进行额外的开发得出的一个分支版本，Paper 和 Spigot 也是这种关系。Paper 和 Spigot 诞生的初衷都是性能改善。</p></div> <p>它们这种关系的特点为「后者可以继承前者所有属性」。也就是说，Spigot 上可以运行所有 Bukkit 的插件，Paper 上可以运行所有 Spigot 的插件。</p> <p>由于后者是前者的分支，那么后者就有可能包含前者不含的内容，而前者却不可能包含后者没有的内容（因为「派生」的关系已经确定了）。因此这三者中的两者（Spigot，Paper）有它们自己的插件支持范畴。即存在一种插件只能在 Spigot 上运行而无法在 Bukkit 上运行，也存在一种插件只能在 Paper 上运行而无法在 Spigot 上运行，但不存在插件只能在 Bukkit 上运行。然而，我们通常接触的插件一般没有这些特点。这些特点是由接口的特性来决定的。</p> <p>这三种服务端均有各自的接口，即 Bukkit API、Spigot API 和 Paper API，它们之间的关系就是这三者之间的派生关系。</p> <h3 id="sponge"><a href="#sponge" class="header-anchor">#</a> Sponge</h3> <p>Sponge 是一个统称，分为 SpongeVanilla 和 SpongeForge。SpongeVanilla 属于插件服务器服务端，拥有一个独特的 API——Sponge API，使得它完完全全从 Bukkit 生态圈中脱离出来。虽然它叫做「插件」，但并不是用 Bukkit 类接口写的。</p> <p>SpongeForge 是模组服务器服务端，算是主流。它实现了对 Sponge API 的支持，同时也实现了对 Forge API 的支持，因而兼容 Sponge API 实现的插件和 Forge API 实现的模组。本文不会提及任何有关 Mod 开发的知识，<s>因为我不会。</s></p> <h3 id="mohist、catserver、arclight-等"><a href="#mohist、catserver、arclight-等" class="header-anchor">#</a> Mohist、Catserver、Arclight 等</h3> <p>这类服务端是模组服务器服务端，支持模组的同时也支持 Bukkit 类插件的安装。它们既实现了对 Forge API 的支持，也实现了对 Bukkit API 的支持。</p> <p>Forge API 和 Fabric API 是客户端流行的两种模组开发接口，服务端需要实现它们才能把模组带到服务端。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>模组和插件的本质区别是一个修改客户端，一个修改服务端，是两个不同的领域。由于客户端与游戏体验紧密挂钩，因此模组通常用于拓展游戏，也可用于客户端优化。插件也可以用于拓展游戏，但使用的均为服务端方法。将模组带入服务端是为了让模组也能进入多人游戏中来。</p></div> <p>以下是一份关于服务端与 API 的关系的简表。</p> <p><c>表 1.1</c></p> <table><thead><tr><th style="text-align:center;">服务端</th> <th style="text-align:center;">API</th> <th style="text-align:center;">支持的插件与 Mod 类型</th></tr></thead> <tbody><tr><td style="text-align:center;">Vanilla</td> <td style="text-align:center;">无</td> <td style="text-align:center;">无</td></tr> <tr><td style="text-align:center;">Bukkit</td> <td style="text-align:center;">Bukkit API</td> <td style="text-align:center;">实现了 Bukkit API 的插件</td></tr> <tr><td style="text-align:center;">Spigot</td> <td style="text-align:center;">Spigot API</td> <td style="text-align:center;">实现了 Bukkit 或 Spigot API 的插件</td></tr> <tr><td style="text-align:center;">Paper</td> <td style="text-align:center;">Paper API</td> <td style="text-align:center;">实现了 Bukkit 或 Spigot 或 Paper API 的插件</td></tr> <tr><td style="text-align:center;">SpongeForge</td> <td style="text-align:center;">Sponge API, Forge API</td> <td style="text-align:center;">实现了 Sponge API 的插件和实现了 Forge API 的 Mod</td></tr> <tr><td style="text-align:center;">SpongeVanilla</td> <td style="text-align:center;">Sponge API</td> <td style="text-align:center;">实现了 Sponge API 的插件</td></tr> <tr><td style="text-align:center;">Mohist 等</td> <td style="text-align:center;">Bukkit 等 API, Forge API</td> <td style="text-align:center;">实现了 Bukkit 等 API 的插件和实现了 Forge API 的 Mod</td></tr></tbody></table> <h2 id="插件"><a href="#插件" class="header-anchor">#</a> 插件</h2> <p>通过上文的阅读，我们应该可以给插件下一个定义了。<strong>Minecraft 服务端插件是一种以特定服务端对应的 API 为实现标准，通过代码上对 API 的实现来对服务端处理客户端请求的过程发挥拓展和改变作用的 Java 应用程序</strong>。通俗来讲，就是通过影响服务端来影响客户端，从而塑造游戏体验或者创造功能的程序。Acetone 主要讲述 Bukkit 类 API 的开发方式，这些方式和思想在不同的 API 下是可以通用的。以下我们就来进行插件开发的第一步。</p> <h3 id="环境部署"><a href="#环境部署" class="header-anchor">#</a> 环境部署</h3> <p>环境部署可以说简单也可以说复杂，实际上取决于自己的需求。本文中介绍的是 Gradle Wrapper 和 Visual Studio Code 来部署针对于 Minecraft 服务端插件的开发环境，也有例如 IntelliJ IDEA 的 IDE 解决方案。</p> <h4 id="_1-java-环境"><a href="#_1-java-环境" class="header-anchor">#</a> 1. Java 环境</h4> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>Ubuntu 若要安装 Java（推荐 OpenJDK）可直接在终端执行指令</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> openjdk-版本-jdk-headless <span class="token comment"># e.g. openjdk-11-jdk-headless</span>
<span class="token comment"># headless 代表没有图形界面相关支持，适用于命令行系统</span>
</code></pre></div><p>一切 Java 基本环境均会帮你配置好。</p></div> <p>Java 是 Minecraft 的基础，也是插件的基础。要安装 Java，请先到<a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>下载 Java 的安装程序。请确保下载到的是 JDK（Java Development Kit，Java 开发包）而不是 JRE（Java Runtime Environment，Java 运行时环境），后者只能运行 Java 程序而不能用来编写。</p> <p>在开发过程中，我们要了解的关于 Java 本体的只有一个参数，就是它的<strong>发行版本</strong>。关于平台版本，作为普通开发者，我们只使用 Java SE（Standard Edition 标准版），而发行版本要依据实际情况而定。通常我们接触到的发行版本有三个，Java 8、Java 11 和 Java 16。通过下表你可以了解到这三个版本之间的区别以及在开发过程中的特点。</p> <p><c>表 1.1-2</c></p> <table><thead><tr><th style="text-align:center;">版本</th> <th style="text-align:center;">特点</th></tr></thead> <tbody><tr><td style="text-align:center;">8</td> <td style="text-align:center;"><a href="https://help.minecraft.net/hc/en-us/articles/360035131371-Minecraft-Java-Edition-System-Requirements-" target="_blank" rel="noopener noreferrer">从 1.12.2 开始<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，Minecraft 要求的最低版本 Java 为 Java 8。目前许多插件的编写仍然可以使用 Java 8 来完成。</td></tr> <tr><td style="text-align:center;">11</td> <td style="text-align:center;">Java 11 是一个 LTS（Long Term Support，长期支持）版本，之前是 Java 8。Java 11 提供了很多 8 没有的特性，同样可以用来运行 Minecraft 客户端和服务端。</td></tr> <tr><td style="text-align:center;">16</td> <td style="text-align:center;"><strong>从 1.17 开始，Minecraft 要求的最低 Java 版本为 Java 16，插件从此也必须至少使用 Java 16 来编写。</strong></td></tr></tbody></table> <p>在 Minecraft 本体支持的前提下，不同的 Java 版本之间最主要的区别是其提供的 Java 本体方法不一样。例如 Java 11 加入了 <code>String.isBlank()</code> 用来判断一个字符串是否为空，这在之前的 Java 版本中均无法使用。如果你用不到这些 API，则可以随性选择。</p> <p>下载完安装程序后安装即可。安装完毕后，在命令行中键入 <code>java --version</code>（Java 8 请使用 <code>java -v</code>）。如果出现版本号，代表安装成功。</p> <p><img src="https://i.loli.net/2021/07/31/IK29V31M6btunrd.png" alt=""></p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>如果显示找不到 <code>java</code> 这个指令，则有可能是环境变量出现问题。</p> <p>在命令行或者 <kbd>Win</kbd>+<kbd>R</kbd> 弹出的运行窗口键入执行</p> <div class="language-batch extra-class"><pre class="language-batch"><code><span class="token command"><span class="token keyword">rundll32</span> sysdm.cpl,EditEnvironmentVariables</span>
</code></pre></div><p>可快速打开环境变量控制面板。接下来编辑环境变量 <code>Path</code>，添加一个项指向 <code>java.exe</code> 所在位置即可。</p> <p align="center"><img src="https://i.loli.net/2021/07/31/UQk6H8BRdbTh94q.png"></p> <p align="center"><img src="https://i.loli.net/2021/07/31/wXsHTkUWBKpg74l.png"></p></div> <h4 id="_2-开发环境"><a href="#_2-开发环境" class="header-anchor">#</a> 2. 开发环境</h4> <p>Java 安装好了以后只是奠定了基础，我们还需要搭建我们日常写代码的地方。一个插件需要写代码、测试、编译、发布，这个地方应当满足我们这些需求。</p> <p>首先，我们要找到一个写代码的地方，也就是编辑器。在本文我们使用 Visual Studio Code（简称 VSC）。如果对 IntelliJ IDEA 感兴趣，可以转到<a href="https://github.com/guobinhit/intellij-idea-tutorial" target="_blank" rel="noopener noreferrer">这篇教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>下载和安装 Visual Studio Code 就不多解释，官网链接为 <a href="https://code.visualstudio.com" target="_blank" rel="noopener noreferrer">https://code.visualstudio.com<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。安装以后打开，在拓展程序里面安装 Java 相关插件（这里的「插件」是用来拓展 VSC 功能的）。本文推荐使用的插件是 <a href="https://marketplace.visualstudio.com/items?itemName=redhat.java" target="_blank" rel="noopener noreferrer">Red Hat 的 Language Support for Java(TM)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，直接在拓展程序里搜索 <code>java</code> 即可找到它。</p> <p align="center"><img src="https://i.loli.net/2021/07/31/ZUyhvlk4gf8EiVq.png"></p> <p>安装好以后，基本上不需要设置。只要之前的 Java 安装没有出现问题，开发环境就已经可以算作搭建完毕。</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>Visual Studio Code 能提供的功能远远少于 IntelliJ IDEA 等专业 IDE，但是对于学习代码来说却显得十分轻量。</p> <p>不同的人可以根据自己的需求来选择不同的 IDE，如果只是写插件用作学习、小作品而不牵涉大项目时，VSC 也是可以接受的。IntelliJ IDEA 的学习成本稍高，但并不属于劝退类型，且大多数特性基本上用不到。</p></div> <h4 id="_3-项目"><a href="#_3-项目" class="header-anchor">#</a> 3. 项目</h4> <p>接下来我们要创建我们的代码存放地。在一个 Java 项目中，一个项目的结构是十分重要的。它相当于一个模板，以后所有的项目基本上均按照该模板或者与该模板相似的结构来组织（本文只是示例，不一定要按照这样来）。一个 Java 项目至少要含有一个 <code>src</code> 目录，其内部为包路径形成的结构以及在特定位置放置的源代码和相关文件，在后文会详细解释。但只有 <code>src</code> 是远远不够的，下文为你介绍了一个 Gradle 项目的基本结构。</p> <p>新建一个文件夹，叫做 <code>my-plugin</code>。在这个文件夹里，我们应当有如下结构</p> <div class="language- extra-class"><pre class="language-text"><code>my-plugin
│  build.gradle
│  settings.gradle
│  gradlew
│  gradlew.bat
│  settings.gradle
├─.gradle
├─gradle
│  └─wrapper
└─src
    └─main
        ├─java
        └─resources
</code></pre></div><p>下表解释了每个文件夹、文件的意义和作用。</p> <p><c>表 1.1-3</c></p> <table><thead><tr><th style="text-align:center;">文件或文件夹</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td style="text-align:center;"><code>build.gradle</code></td> <td style="text-align:center;">用于指定该项目的构建信息，例如该项目的版本、兼容性等。最重要的是，该文件可以用来添加<strong>依赖</strong>。API 本身也是一种依赖，因此该文件不可或缺</td></tr> <tr><td style="text-align:center;"><code>settings.gradle</code></td> <td style="text-align:center;">用于配置项目，功能不大</td></tr> <tr><td style="text-align:center;"><code>gradlew</code> 和 <code>gradlew.bat</code></td> <td style="text-align:center;">用来调用 gradle 本体的两个脚本，功能完全相同，支持的系统有别。没有加 <code>.bat</code> 的用于 bash，加了 <code>.bat</code> 的用于 Windows 的 cmd</td></tr> <tr><td style="text-align:center;"><code>.gradle</code></td> <td style="text-align:center;">用于存放 gradle 相关文件，如不同版本的 gradle 等</td></tr> <tr><td style="text-align:center;"><code>gradle</code></td> <td style="text-align:center;">用于存放 gradle 包装器 <code>gradle-wrapper</code></td></tr> <tr><td style="text-align:center;"><code>src</code></td> <td style="text-align:center;">项目所有代码以及相关文件的存放地</td></tr> <tr><td style="text-align:center;"><code>src/main</code></td> <td style="text-align:center;">主程序代码以及相关文件的存放地。我们在开发插件时必须将代码放在 <code>main</code> 文件夹内</td></tr> <tr><td style="text-align:center;"><code>src/main/java</code></td> <td style="text-align:center;">主程序代码的存放地。其内部存在一个嵌套的目录，目录的结构反映了<strong>包名</strong></td></tr> <tr><td style="text-align:center;"><code>src/main/resources</code></td> <td style="text-align:center;">主程序相关文件的存放地。该文件夹内必须包含一个 <code>plugin.yml</code> 用于声明该插件本身的一些信息，如版本、指令、权限等</td></tr></tbody></table> <p>以下是一些基本问题的解释。</p> <ul><li><strong>Gradle 是什么？它有什么作用吗？</strong> Gradle 是一个<strong>包管理程序</strong>，你可以通俗地认为它是用来管理你项目本身的编译（构建）和发布事项，同时提供一个将其它需要的依赖引入本地项目的途径的第三方程序。除了 Gradle 以外还有 Maven 等，你也可以选择 Maven 作为包管理程序，它们的作用大同小异。本文仅介绍 Gradle。</li> <li><strong>Gradle Wrapper 又是什么？Gradle 不需要下载安装就可以使用吗？</strong> Gradle 本身更新的很频繁，且对外的接口经常改，为了方便使用，出现了 Wrapper（包装器）的概念。包装器对 Gradle 进行包装，包装的结果就是一个具有统一调用方式的程序，这样就可以有效避免 Gradle 本身迭代过快造成的不便。Gradle Wrapper 在我们的项目中起到的作用是调用 Gradle 本体进行构建等操作。Gradle 可以<a href="https://gradle.org" target="_blank" rel="noopener noreferrer">下载<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，也可以直接通过文件来调用 Gradle Wrapper，本文考虑后者。</li> <li><strong>依赖是什么？</strong> 插件作为一个 Java 应用程序，包含其本身的一些特点。我们一般把我们自己在本项目中写的代码称为本地代码，任何非本地代码均为依赖。在编写过程中如果需要引用别人（或者自己其它项目）的代码功能，按照一般的思路，需要将它先下载到本地，放入我们的项目中，再进行导入，这是很麻烦且不优雅的，在更新迭代的时候也会出现一些问题。包管理程序提供了优雅的解决方式，网上的一些平台（如 <a href="https://mvnrepository.com/" target="_blank" rel="noopener noreferrer">MVN Repository<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）让开发者们把自己的「作品」发在上面，如果有人有需要则可以直接通过一个链接将其作为<strong>依赖</strong>通过包管理程序导入自己的项目里。Bukkit 类 API 均是外部的代码，因而我们必须要把它作为依赖「导入」，才能正常编写和调用它的内容。</li> <li><strong>包名是什么？</strong> 这是 Java 的知识。通俗来讲，如果你想要写一个 Java 程序，它必须有自己的包名。如果只是自己写，包名则可以随便定。例如 <code>animal</code>、<code>animal.mammal</code>。但是对于插件这种一般都会发布到外界的项目来说，为了互相区分，包名一般由域名+本地包名组成。域名用于将自己的项目与他人的隔开。例如如果我自己的网站是 <code>subilan.win</code>，我写了程序叫做 PerfectApplication，经过组合它的包名就是 <code>win.subilan.PerfectApplication</code>，对应的目录结构就是 <code>win/subilan/PerfectApplication/</code>，放在本项目中，我的代码就应该全部放在 <code>src/main/java/win/subilan/PerfectApplication</code> 下面。当然，包名是自由的，这和你有没有自己的网站没有必然联系，但域名依然很重要，你也可以自己创造一个域名。例如很有可能有另外一个人也写了一个 PerfectApplication，如果彼此拥有不一样的域名，就不会产生冲突。</li> <li><strong>我该从哪里搞到这些我没有的文件？</strong> 对于 gradle 一系列的文件，如果你对 gradle 不甚了解，我建议你直接从<a href="#">这里</a>下载，然后复制到你的项目里面。如果你对 gradle 有了解或者有意向学习，请前往<a href="https://gradle.org/" target="_blank" rel="noopener noreferrer">官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>查看相关内容，有关 Gradle Wrapper 的文档在<a href="https://docs.gradle.org/current/userguide/gradle_wrapper.html" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。对于目录，需要自己创建。你也可以通过<a href="#">这个小程序</a>来帮助你创建。</li></ul> <div class="custom-block danger"><p class="custom-block-title">WARNING</p> <p>上文提供的直接下载链接指向的是我一直使用的版本，它们并不支持 Java 16 的开发。</p></div> <p>接下来介绍 <code>plugin.yml</code>、<code>build.gradle</code> 和 <code>settings.gradle</code>。这些文件共同决定了整个项目的基本性质。先说最简单的 <code>settings.gradle</code>。</p> <div class="language-groovy extra-class"><pre class="language-groovy"><code>rootProject<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'项目名称'</span>
</code></pre></div><p>只有这一行内容。填写你的项目名称即可。如需了解更多可以放在这个文件里面的项目，可以查看<a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:settings_file" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>对于 <code>build.gradle</code>，请先参考以下结构和注解。</p> <div class="language-groovy extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br></div><pre class="language-groovy"><code>plugins <span class="token punctuation">{</span>
    id <span class="token string">'java'</span>
<span class="token punctuation">}</span>

group <span class="token string">'com.example'</span> <span class="token comment">// 包前面的域名部分</span>
version <span class="token string">'1.0.0'</span> <span class="token comment">// 项目的版本</span>
ext<span class="token punctuation">.</span>minecraftVersion <span class="token operator">=</span> <span class="token string">'1.16.5'</span> <span class="token comment">// 这是一个变量，填当前插件所使用的 API 对应的版本。</span>
mainClassName <span class="token operator">=</span> <span class="token string">'com.example.MyPlugin.Main'</span> <span class="token comment">// 主类地址。前面的 com.example.MyPlugin 是包名，Main 是类名</span>

jar <span class="token punctuation">{</span>
    manifest <span class="token punctuation">{</span>
        attributes <span class="token string gstring">&quot;Main-Class&quot;</span><span class="token punctuation">:</span> <span class="token string gstring">&quot;<span class="token expression"><span class="token punctuation">$</span>mainClassName</span>&quot;</span> <span class="token comment">// 这里引用了上面的变量，用来指定主类。</span>
    <span class="token punctuation">}</span>

    from <span class="token punctuation">{</span>
        configurations<span class="token punctuation">.</span>runtimeClasspath<span class="token punctuation">.</span>collect <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> it <span class="token punctuation">:</span> <span class="token function">zipTree</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

sourceCompatibility <span class="token operator">=</span> <span class="token number">11</span> <span class="token comment">// 代码的兼容版本（Java）</span>

repositories <span class="token punctuation">{</span> <span class="token comment">// 这里写的都是仓库的地址，仓库就是上文中所说的「平台」。这里相当于是在引入这些仓库</span>
    <span class="token function">jcenter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">mavenCentral</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    maven <span class="token punctuation">{</span> name <span class="token string">'Spigot'</span><span class="token punctuation">;</span> url <span class="token string">'https://hub.spigotmc.org/nexus/content/repositories/snapshots/'</span> <span class="token punctuation">}</span> <span class="token comment">// 这个就是 Spigot 自己的仓库，引入以后才能获取到 Spigot API</span>
    maven <span class="token punctuation">{</span> name <span class="token string">'Sonatype'</span><span class="token punctuation">;</span> url <span class="token string">'https://oss.sonatype.org/content/groups/public'</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

dependencies <span class="token punctuation">{</span>
    compileOnly <span class="token string gstring">&quot;org.spigotmc:spigot-api:<span class="token expression"><span class="token punctuation">$</span>minecraftVersion</span>-R0.1-SNAPSHOT&quot;</span> <span class="token comment">// 导入 Spigot API 相应版本作为依赖。注意此处用到了上面的版本变量</span>
    testImplementation <span class="token string">'junit:junit:4.13'</span>
    testImplementation <span class="token string">'com.google.code.findbugs:jsr305:3.0.2'</span>
<span class="token punctuation">}</span>

tasks<span class="token punctuation">.</span><span class="token function">withType</span><span class="token punctuation">(</span>JavaCompile<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 指定编译时的编码</span>
    options<span class="token punctuation">.</span>encoding <span class="token operator">=</span> <span class="token string gstring">&quot;UTF-8&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>突出的两行如果出现问题，将导致插件无法开发，因为 API 没有被正常导入。</p></div> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>实际上 <code>build.gradle</code> 和 <code>settings.gradle</code> 都是用一种叫做 Groovy 的语言写的，相当于比较随意的 Java。</p></div> <p><code>build.gradle</code> 内需要着重掌握的地方，只有 <code>dependencies</code> 和 <code>repository</code> 环节和开头的 <code>group</code>、<code>version</code> 等量。若在编写插件时需要引入依赖，通常的流程是找到依赖的发布地址然后加入到 <code>dependencies</code> 里面。以要加入 <a href="https://github.com/neko-craft/NekoCommander" target="_blank" rel="noopener noreferrer">NekoCommander<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 为依赖为例，作者在 <code>README.md</code> 里面写了如下内容</p> <p><img src="https://i.loli.net/2021/07/31/7qxCQ3T4gtSzXmM.png" alt=""></p> <p>意思是让你到 <code>build.gradle</code> 的相应部分添加相关内容。添加完毕以后，等待片刻（或者重启 VSC 的窗口，<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>，输入 Reload Window 后 <kbd>enter</kbd>），项目中即可直接 <code>import</code> 相关包。这就完成了依赖的导入，大部分依赖的导入流程均是如此，十分快速。</p> <p>关于 <code>plugin.yml</code>，请参考以下结构和注解</p> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">name</span><span class="token punctuation">:</span> MyPlugin <span class="token comment"># 插件的名称</span>
<span class="token key atrule">main</span><span class="token punctuation">:</span> com.example.MyPlugin.Main <span class="token comment"># 插件的主类地址</span>
<span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;1.0.0&quot;</span> <span class="token comment"># 插件的版本</span>
<span class="token key atrule">author</span><span class="token punctuation">:</span> Myself <span class="token comment"># 插件的作者，如果有多个可以写成 [A, B, C, ...]</span>
<span class="token key atrule">api-version</span><span class="token punctuation">:</span> <span class="token string">&quot;1.16&quot;</span> <span class="token comment"># 插件所使用的 API 版本</span>
<span class="token key atrule">api</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token key atrule">depend</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token key atrule">softdepend</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token key atrule">website</span><span class="token punctuation">:</span> <span class="token string">&quot;https://example.com&quot;</span>

<span class="token key atrule">commands</span><span class="token punctuation">:</span> <span class="token comment"># 插件的指令</span>
  <span class="token key atrule">myplugin</span><span class="token punctuation">:</span> <span class="token comment"># 指令名称</span>
    <span class="token key atrule">aliases</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;my&quot;</span><span class="token punctuation">]</span> <span class="token comment"># 指令别名，此时 /my 和 /myplugin 等价</span>
    <span class="token key atrule">description</span><span class="token punctuation">:</span> Myplugin command <span class="token comment"># 指令介绍</span>
    <span class="token key atrule">permission</span><span class="token punctuation">:</span> myplugin.command <span class="token comment"># 指令对应的权限</span>
    <span class="token key atrule">permission-message</span><span class="token punctuation">:</span> <span class="token string">&quot;You do not have the permission to use the command.&quot;</span> <span class="token comment"># 没有权限时要显示的信息</span>
    <span class="token key atrule">usage</span><span class="token punctuation">:</span> The command is invalid or you don't have the permission to use it. <span class="token comment"># 指令的用法信息</span>
<span class="token key atrule">permissions</span><span class="token punctuation">:</span> <span class="token comment"># 插件的权限</span>
  <span class="token key atrule">myplugin.use</span><span class="token punctuation">:</span> <span class="token comment"># 权限名称</span>
    <span class="token key atrule">default</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 默认给予所有玩家</span>
  <span class="token key atrule">myplugin.admin</span><span class="token punctuation">:</span>
    <span class="token key atrule">default</span><span class="token punctuation">:</span> op <span class="token comment"># 默认给予 OP 玩家</span>
  <span class="token key atrule">myplugin.never</span><span class="token punctuation">:</span>
    <span class="token key atrule">default</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 默认不给予玩家</span>
</code></pre></div><p>该文件内的信息决定了插件在服务端内的最终表现。如果没有正常填写，无论其它文件是否正常填写，服务端均无法处理。例如如果主类填写错误，那么服务端将无法 enable 该插件。服务端内显示的该插件的版本号也是由该文件所控制。有关 <code>plugin.yml</code> 完整的解释，可以查看 <a href="https://www.spigotmc.org/wiki/plugin-yml" target="_blank" rel="noopener noreferrer">Spigot 官方 Wiki<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>以上就是环境部署部分。</p> <h3 id="插件编写"><a href="#插件编写" class="header-anchor">#</a> 插件编写</h3> <p>从现在开始，基础部分已经结束，接下来重点展开对插件编写本身的叙述。具体的各种功能的实现方法将会在后面的各个章节详细讲解，下面来简略了解一些基本信息。</p> <h4 id="_1-插件制作的基本流程"><a href="#_1-插件制作的基本流程" class="header-anchor">#</a> 1. 插件制作的基本流程</h4> <p>插件是一个标准的 Java 应用程序，这意味着它具备一个应用程序所具有的特点。我们应该都知道程序与语言之间的关系：我们所写的 Java 文件里的代码，需要通过编译器的编译才能够转换为能够运行的「程序」。插件开发也是如此，这个经过转换最终得到的「程序」，便是我们已经熟知的 <code>jar</code> 文件——只要把它丢进 <code>plugins</code> 文件夹里，就可以被服务端自动识别然后启用了。于是我们可以知道一个插件制作的基本流程包含如下几点</p> <ul><li><strong>搭建环境</strong> 包括 Java 环境、项目环境等。这些环境经过一次搭建以后，一般不需要再去「折腾」第二次。例如 Java 环境，只要不把 Java 删掉，实际上是一直存在的，不需要重复搭建（除非有所需求，比如更换版本等）；又如项目环境，一般每个项目都是一样的目录结构，项目与项目之间的最大区别大概只是代码、<code>build.gradle</code> 和包路径了，因而先前搭建的内容均可以拿来重复使用，并不需要多费脑力。</li> <li><strong>编写代码</strong> 利用相应的 API 在相应的目录的特定文件里面编写代码。</li> <li><strong>编译</strong> 利用 <code>gradle</code> 对你的代码进行编译打包，输出一个 <code>jar</code> 文件。</li> <li><strong>发布</strong> 将你的插件发布出去，使其安装到服务器上发挥作用。</li></ul> <p>Acetone 讲述的重点是第二点，但其它也会有提及。</p> <h4 id="_2-编译概述"><a href="#_2-编译概述" class="header-anchor">#</a> 2. 编译概述</h4> <p>作为插件开发者，如果没有特别的要求，我们不需要对 Java 的各种原理，包括编译器等了解得很详细。在这里，我们将以初学者的角度来了解在插件开发过程中的编译操作。编译操作本质上就是通过一个中间程序（编译器）将源代码翻译成机器码的过程，但是因为不同的语言、不同的目标文件以及编译器本身的不同，这个概念被拓展了许多，编译器也不只是编译器，能完成这个操作的也不只有编译器。避免复杂化，我们将其通俗地理解为<strong>编译是把我们的 Java 代码转化为可运行的 <code>jar</code> 文件的过程</strong>。</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>这并不代表插件开发领域完全没有对这方面知识的要求，只是我们平常随便写的插件都不大需要。因此，如果想要在插件开发的路上走得长远，Java 的知识需要稳扎稳打。</p></div> <p>那么该如何编译我们的插件呢？通过 <code>gradle</code>，这也是 <code>gradle</code> 的重要所在。编写完代码以后，在项目的根目录（即 <code>gradlew.bat</code> 等的所在地）执行以下指令</p> <div class="language-batch extra-class"><pre class="language-batch"><code>./gradlew build
</code></pre></div><p>这句指令的意义是调用当前目录下的 <code>gradlew</code> 文件并向其传递一个参数 <code>build</code>。根据程序的不同，它们所接受的参数以及给出的回应也不同，你可以执行 <code>./gradlew --help</code> 来查看可用的参数。编译完成后， <code>jar</code> 文件会被放在 <code>/build/libs/</code> 下面，你可以直接将其放到你的服务器上运行。</p> <p>更加具体的编译过程详见 <a href="/content/1.2.html">1.2 我们的第一个插件</a>。</p> <h4 id="_3-解决问题"><a href="#_3-解决问题" class="header-anchor">#</a> 3. 解决问题</h4> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>此部分较长，但值得一读。</p></div> <p>在编写插件的时候，我们往往会遇到如下几种问题：</p> <ul><li>不知道一个函数该如何使用</li> <li>不知道一个功能该怎样实现</li> <li>遇到了不认识的报错</li></ul> <p>这些问题大都是具有阻碍性的，它会让我们下面的编写工作十分难以进行，所以必须要解决它们。解决它们并不是纯靠自己的硬知识本领，因为并没有几个人能够做到完全将 Java 的各种概念烂熟于心，并且遇到一些特殊的错误都能立马想出解决方案。在程序员的世界里，用搜索引擎搜索问题是十分普遍的行为。我们在开发插件的时候，使用搜索引擎搜索我们的问题的效率比我们干巴巴地猜想要高得多。</p> <p>同时，对于 Java 这种语言来说，还有一个比较特殊的「搜索」，那就是 <strong>Javadoc</strong>。Javadoc 本意是一个文档生成器，在这里泛指与之相关的「文档」概念。简单来说，Javadoc 就是依据在编写 Java 代码的时候，针对不同的函数、类等主体，人为添加的各种注释信息所生成的一套文档。它有什么用呢？因为许多 Java 程序都很庞大，尤其是 API 这类，它们往往需要提供给外部使用，同时功能又很繁多，为了让所有人都能高效率地了解到这个 API 里的每一个元素（在这里泛指函数、类等概念）都有什么作用以及该如何使用（参数、类型等），作者就会在编写代码的时候为需要的元素添加注释，然后生成 Javadoc 提供给外部查阅。这样使用者只需要输入自己有疑问的函数之类，就可以查找到详尽且对应的解释。Javadoc 文档一般都是 HTML，因而大多以网页的形式呈现。</p> <p>阅读了上面两段文字，你是否对解决问题的方法又有了新的思考？函数不会用的时候，我们可以去查 Javadoc；遇到不认识的报错的时候，我们可以去搜索引擎里面搜索相关的内容。然而，平常我们在国内网络所使用的百度，并不太适合开发目的的搜索。虽然百度有专门为开发者设计的搜索平台，但依然在短期内无法实现成熟的支持。这体现在哪里呢？</p> <ul><li>首先，我们所接触到的 API 基本上都是外国的作品，而百度很少会收录相关的网页，意思是哪怕你用英语去搜也不一定搜得到，所以我们在百度上基本上查不到我们所需要的<strong>第一手</strong>资料，大多均为他人所写的随想或者经验，它们往往具有价值，但很多时候不能让我们解决问题。</li> <li>其次，国内并没有高质量的程序员知识问答平台。对比国外的 StackOverflow 甚至 GitHub 等，它们往往会有很多含有含金量的内容。而国内网络大都是一些博客，质量参差不齐（此处承认依然存在高质量博客），即使是思否、知乎这样看似稍微好那么一点的平台，实际上提供的有价值的信息并不多。</li> <li>最后，使用英文搜索能够更好地描述我们的问题，尤其是报错。在国外的搜索引擎里，基本上只需要复制报错然后粘贴，即可得到 StackOverflow 等网站的有效结果。但是在百度上并不能用英文搜索，我们在用中文描述问题再去搜索，也许会发现根本没有一条与我们的问题相关，造成这种现象的原因有很多。</li></ul> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>百度的收录机制过于刁钻，很多个人博主的个人网站无法得到曝光，也导致了一些精品内容的流失。</p></div> <p>因此，这里给出的建议是</p> <ul><li>使用非百度搜索引擎。不一定是国外的搜索引擎，当然如果有条件使用 Google 更好。国内仍然可以使用的一些，比如 Bing 等，也可以填补我们的需求。不使用百度的原因有很多，其一是其收录网页的条件过于刁钻，且基本上只挑国内的内容。</li> <li>使用英文搜索。无论是复制粘贴你的报错，还是用纯英文描述你的问题，都能够在非百度搜索引擎里得到较为符合的结果。当然，这一项可能门槛较高，但如果你确实会英语（也不需要很精通），应当尽量使用英语搜索，用中文搜索大多数情况下依然可以，但对于罕见错误也许就不大奏效了。</li></ul> <p>下面我们以 JavaScript 脚本的后加载问题进行搜索对比。首先我们使用英文在 Google 上搜索，得到的结果几乎全部都是相关的。</p> <p><img src="https://i.loli.net/2021/08/05/9Pxj4ZaFsKXroB1.png" alt="1.PNG"></p> <p>然后我们用中文在 Google 上搜索，得到的结果也是差不多相关的，它们都变成了国内的网页。</p> <p><img src="https://i.loli.net/2021/08/05/bYJU8hu6yQtgIpF.png" alt="2.PNG"></p> <p>接下来使用中文在百度上搜索，我们不去评价搜索界面上元素的差异，的确可以搜到相关的结果且出现在第一位，但实际上这一部分只有 5 个结果，其中只有 2 个（第一个和第五个）是有关内容，其余的只是关键词相同但是截然不同的问题。</p> <p><img src="https://i.loli.net/2021/08/05/sb7jazthu4df6g3.png" alt="3.PNG"></p> <p>接下来使用英文在百度上搜索，没有有关结果。第四个结果出乎意料地出现了 StackOverflow 的内容，可惜毫不相干。</p> <p><img src="https://i.loli.net/2021/08/05/qWsAU2gxIJn67fR.png" alt="4.PNG"></p> <p>通过这个实验我们就可以发现一些问题。对于我们个人来说，选择最适合自己的才是最重要的。如果你说你不会英文，也不大需要较高的准确率，百度用着其实还是很舒服的，本文也只是给予建议。这并不是在「崇洋媚外」，更不是在诋毁百度（大家有目共睹），而是在开发的过程中不断体验出来的；当你进行开发有一段时间以后，相信你也可以体验出它们的差别。</p> <p>对于 Javadoc，最好在我们对插件开发比较熟悉的时候接触，此处暂且不提。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/content/1.2.html">
        1.2 我们的第一个插件
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.770deb9e.js" defer></script><script src="/assets/js/2.ccae3753.js" defer></script><script src="/assets/js/3.df5561e6.js" defer></script><script src="/assets/js/10.abbb295a.js" defer></script>
  </body>
</html>
