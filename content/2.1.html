<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>2.1 配置文件 | Acetone</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="以较快的方式了解 Minecraft 服务端插件开发">
    
    <link rel="preload" href="/assets/css/0.styles.fb41c43f.css" as="style"><link rel="preload" href="/assets/js/app.73f7e960.js" as="script"><link rel="preload" href="/assets/js/2.ccae3753.js" as="script"><link rel="preload" href="/assets/js/3.df5561e6.js" as="script"><link rel="preload" href="/assets/js/12.d65e9248.js" as="script"><link rel="prefetch" href="/assets/js/10.fafe178e.js"><link rel="prefetch" href="/assets/js/11.cdb98f42.js"><link rel="prefetch" href="/assets/js/4.73aae1e1.js"><link rel="prefetch" href="/assets/js/5.105d4b4e.js"><link rel="prefetch" href="/assets/js/6.a1052a6d.js"><link rel="prefetch" href="/assets/js/7.9f6e63f8.js"><link rel="prefetch" href="/assets/js/8.d3aa661c.js"><link rel="prefetch" href="/assets/js/9.c94b37f7.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fb41c43f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Acetone</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/about.html" class="nav-link">
  关于
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/about.html" class="nav-link">
  关于
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>入门</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/content/1.1.html" class="sidebar-link">1.1 插件的概念</a></li><li><a href="/content/1.2.html" class="sidebar-link">1.2 我们的第一个插件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/content/2.1.html" aria-current="page" class="active sidebar-link">2.1 配置文件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/content/2.1.html#配置文件的意义" class="sidebar-link">配置文件的意义</a></li><li class="sidebar-sub-header"><a href="/content/2.1.html#配置文件的实现" class="sidebar-link">配置文件的实现</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_2-1-配置文件"><a href="#_2-1-配置文件" class="header-anchor">#</a> 2.1 配置文件</h1> <p>**配置文件（configuration）**是大部分面向用户的程序在运行中所需要依赖的指导性文件。假设我们的插件有一个功能 A，但是这个功能 A 在不同的服务器上表现不一样，在一些不好的情况下它有可能导致服务器无法正常运行，但是有些人却需要它，这该怎样实现？不难想到，我们需要给这个功能加上一个「开关」，而这个开关所牵涉到的就是配置文件。</p> <p>本节内容将详细介绍 <code>plugin.yml</code> 的内容及其作用以及处理插件配置文件的方法及相关介绍。</p> <h2 id="配置文件的意义"><a href="#配置文件的意义" class="header-anchor">#</a> 配置文件的意义</h2> <p>配置文件本质上是程序向外部所开放的可配置部分。配置文件为用户提供了一个简易的、稳定的直接影响程序表现的途径。如果没有配置文件，用户想要禁用掉功能 A 来让自己的服务器正常运行，必须得去自己改代码，否则就啥也干不了。改代码就比较麻烦了，修改代码得先知道代码，然后把功能 A 的相关代码去掉，再调试是否对其它的功能有所影响，再编译一份属于自己的插件······</p> <p>如果作为开发者的我们提前将这一部分逻辑处理好，将「启用 A」放到一个布尔值，比如 <code>aEnabled</code> 里，然后在实现功能 A 的时候加入 <code>if (aEnabled) {} else {}</code> 部分，那么用户只需要改变 <code>aEnabled</code> 这个值便可以改变其运行情况，十分方便。</p> <p>所以，配置文件所提供给用户的就是修改程序内部分数据的能力。我们放在配置文件中的不一定是上面例子中的开关，而可以是程序需要向用户询问的一切东西：</p> <ul><li>不允许进入服务器的玩家名字有哪些？</li> <li>服务器开了多久关？</li> <li>服务器的密码是多少？</li> <li>启用不启用这个功能？</li> <li>...</li></ul> <p>通过配置文件，用户可以轻松修改插件所开放给他们的配置项目，插件也可以根据这些项目合理地运行来达到用户想要的效果。</p> <h2 id="配置文件的实现"><a href="#配置文件的实现" class="header-anchor">#</a> 配置文件的实现</h2> <p>配置文件可以用多种数据形式来实现。首先，我们需要理解键（key）—值（value）思想，这在大多数编程语言中是通用的。</p> <h3 id="键-值概述"><a href="#键-值概述" class="header-anchor">#</a> 键—值概述</h3> <p>键—值是一种通用的数据存储模式，在主流语言中都可以见到它的身影。</p> <p><strong>键</strong>是一个值的标识符（identifier），简而言之就是一个值独一无二的标志。<strong>值</strong>是一个具有实际意义的字段。键与值一一对应，知道了键，就可以找到值。一个键对应一个值的整体称为<strong>键—值对</strong>。如下结构表达了一个简单的<strong>键—值对</strong>集合：</p> <div class="language- extra-class"><pre class="language-text"><code>a: 1, b: 2, c: 3
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>键—值对集合的另外几种说法</strong></p> <p>还可以叫做<strong>字典（dictionaries）<strong>或者</strong>映射（mappings）</strong>，因为键—值对实际上是在将键映射到值上（可以想象存在一个键域和一个值域，一个函数 f(k) 将键 <code>k</code> 对应的值返回）。</p> <p>需要注意的是，叫法只是叫法，它们代指的并不仅仅是「键值对集合」这样一个简单的东西。不同（或同一）编程语言中键值对集合的形式可能有很多种，它们具有各自的独特性质，这需要从编程语言的设计方面进行了解。例如 Python 中有字典这种数据类型，Java 中有映射（<code>Map&lt;U,T&gt;</code>）这种数据类型。</p></div> <p>这里我们可以说，键 <code>a</code> 对应值 <code>1</code>，键 <code>b</code> 对应值 <code>2</code>，键 <code>c</code> 对应值 <code>3</code>。上面只是一个模式性的表达，实际上遵循键—值表达模式的有专门的数据表达语言，例如 JSON、YAML 等。在 Bukkit 开发中，我们大部分时间都会用到 YAML 这种格式。上述结构在 JSON 中的表达是这样的：</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
    <span class="token property">&quot;a&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token property">&quot;b&quot;</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token property">&quot;c&quot;</span><span class="token operator">:</span> <span class="token number">3</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果将它变为一个对象 <code>obj</code>，那么我们可以通过 <code>.</code> 号来访问该对象下的键从而获取对应的值。在这个例子中，<code>obj.a</code> 为 <code>1</code>，<code>obj.b</code> 为 <code>2</code>，<code>obj.c</code> 为 3。</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>在这里的 <code>.</code> 与包名中的 <code>.</code> 泛指含义相同，都是指所属关系，但在编程上的含义完全不同。我们不能说 <code>com.example.myplugin.Main</code> 中的任何一部分是「键」，它们更没有值。但值得注意的是，包名的表达方式和键在本质上是相同的，都一个数据主体的独一无二标识。</p></div> <p>上述结构在 YAML 中的表达是这样的：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">a</span><span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token key atrule">b</span><span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token key atrule">c</span><span class="token punctuation">:</span> <span class="token number">3</span>
</code></pre></div><p>可见，不同的数据表达语言对数据的表达方式并不一样，但是并不会改变最初的键—值模式，更不会改变数据本身的键和值。所以它们本质上只是写法和解析方式不同，属于同一组数据的不同记法而已。但是不同的数据表达语言之间又有很大的差异，你将在其它类型的开发工作中感受到这一点。</p> <h3 id="yaml-文件"><a href="#yaml-文件" class="header-anchor">#</a> YAML 文件</h3> <p>接下来我们详细介绍我们随后会经常接触到的 YAML 文件。YAML 是一个缩写，在发布后的全称是 <strong>Y</strong>AML Ain't a Markup Language（YAML 不是一种标记语言）。注意 YAML 的全称中仍然有 YAML 这个缩写（这种缩写形式称为巡回缩写），所以可以认定 YAML 是个单纯的名字。</p> <p>YAML 文件的扩展名为 <code>.yml</code>，创建以后可直接在里面写 YAML 内容。</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">a</span><span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token key atrule">b</span><span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token key atrule">c</span><span class="token punctuation">:</span> <span class="token number">3</span>
</code></pre></div><p>和 JSON 一样，YAML 中的值是有数据类型的。对于上面例子中的 <code>1</code>，实际上是整数（Integer）<code>1</code>。如果我们要把它表达为字符串 <code>1</code>，可以将其加上引号：<code>a: &quot;1&quot;</code>（单引号也可）。对于那些可以直接被看作数字的值，例如 <code>1</code>、<code>1.2</code> 等，会被直接解析为相应的数字数据类型。而那些不能被看作数字的值，例如 <code>1A</code>、<code>2021/08/11</code>、<code>'1'</code>，则会被看作是字符串。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>如果 <code>a: 1A</code>，此时无论 <code>1A</code> 是否打引号都是一个字符串。</p></div> <p>如字符串、数字这种不可再分的值，在 YAML 中称为纯量。YAML 中还有另外两类可再分的值，一种叫做<strong>对象</strong>，一种叫做<strong>数组</strong>。对象和数组都是可以嵌套的，这也是为什么它们可以再分。下面来分别简单介绍对象和数组。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/content/1.2.html" class="prev">
        1.2 我们的第一个插件
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.73f7e960.js" defer></script><script src="/assets/js/2.ccae3753.js" defer></script><script src="/assets/js/3.df5561e6.js" defer></script><script src="/assets/js/12.d65e9248.js" defer></script>
  </body>
</html>
